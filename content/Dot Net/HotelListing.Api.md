![[{8DC6B2E2-FD3C-4C25-9949-290DD9547CDC}.png]]
اینجا وقتی که تعیین کردیم که route  روی controller باشه ، اینطوری میشه که هر وقت درخواستی با اسم اون کنترلر بیاد اون فعال میشه و یه پاسخی رو برمیگردونه اینجا اسم کنترلرمون weatherForcast هستش 

![[{74307FCE-A30B-4314-B14C-AD4BE5A421D3}.png]]
حالا اگر بزنیم weatherForcast/GetWeatherForcast این متد فعال میشه و یه دیتایی رو برای ما برمیگردونه 

نکته : lunch setting همونطوری که از اسمش پیداست یعنی چیزهایی که نیازه برای این که پروژه رو اجرا کنیم و راه بندازیم :
![[{24BCA30C-B9C9-4292-A282-623B7CE2C9B7}.png]]
ولی appSetting  چیزهایی هستش که ما برای develpment میخوایم استفاده کنیم 

![[{08112018-2DF0-4718-A2E4-6805348C7F9D}.png]]


نکته اگر بخوایم سرویسی رو تعریف کنیم میایم اون ها رو بین builder و builder.build تعریفشون میکنیم :

![[{321A5994-5A0B-4F97-8390-2A43D0E8FEE5}.png]]

 و نکته ی بعدی اینه که اگر بخوایم middleware رو تعریف کنیم میایم بین app و app.run تعریفش میکنیم :

![[{E3633229-AA58-4B6A-B107-80B4291DCA75}.png]]
خوب اون builder که داره سرویس ها و چیزهایی که برنامه میخواد ازشون استفاده کنه قبل از این که app.build بشه رو فراهم و آماده میکنه برای همین بهش میگن IOC Controller یا همون inverstion of control container 

خوب وقتی که به app میشه دیگه ما میایم middleware ها رو اضافه میکنیم که این به request pipline تاثیر میزاره 
![[{F0FC4EAE-AA02-4073-A493-3A9FA2DE71AD}.png]]

خوب یاینجا به طور مثال داره میگه اگر روی ماشین خودمون و در حالت development داریم کد رو اجرا میکنیم بیاید و از این ها استفاده کنه و اون ها رو اجرا کنه swagger و swaggerUI  

![[{2842B87B-E931-450B-BFFD-EFD1ACA9C33B}.png]]
این برای اینه که همیشه از https استفاده کنیم 

خوب model ها برای این هستند که دیتا چه شکلی باید باشن 
![[{179277C6-F119-4C1D-95AB-3F2EC2249014}.png]]

 
تعریف cors  این برای این هستش که client های مختلفی که روی سرور من نیستند هم بتونند به این api دسترسی داشته باشند 

![[{C7357C4C-82A3-4A19-8267-96C5A7A6EC4A}.png]]

https://www.bytehide.com/blog/cors-aspnet-core

In this guide, we’ll unravel the core principles of Cross-Origin Resource Sharing (CORS) in ASP.NET Core. We will cover its role in web applications, provide practical examples and highlight some common mistakes to avoid.

Let’s dive in!


## Introduction to CORS

Ever wondered about the invisible rules that keep your website interactions safe and secure? That’s where CORS, or Cross-Origin Resource Sharing, comes in. This primer will help us understand its importance in our web applications.

### Understanding CORS and Its Importance

CORS or Cross-Origin Resource Sharing is the guardian angel that allows or restricts external domains to access resources from your domain. Imagine you’re hosting a party (your website), and CORS is the bouncer deciding who gets in (requests) based on the guest list (rules you’ve set). Oh, and that party? It’s one thrilling and secure online experience!

![[{83307703-5432-4163-B21F-FC7DDD5AEF47}.png]]

### How Does CORS Work

Once you send a request from a client to a server in the dance of web communication, the server responds with access control headers. These headers decide who gets to dance along to the beat (the resources). But hey, let’s not only talk in riddles, let’s dive deeper into CORS’s working mechanism in ASP.NET Core context in the next sections.

![[{776E9F6D-C9A2-4273-8439-04072A19A9F5}.png]]

### Step-by-step Guide to Enabling CORS in Web API NET Core


![[{2ECEFB75-2CE5-4BF0-9860-7E18176D4E63}.png]]

### Understanding NET Core Allow CORS Methods

![[{F5D7D3D8-9557-4D6E-A39F-076451A5B267}.png]]



![[{0AC37B19-B5F4-4423-8472-CAC35F4D4F33}.png]]

https://www.bytehide.com/blog/cors-aspnet-core


بعدا  کامل مطالعه شود

![[{D429724E-2B2D-4EF8-AB5A-3B154D732EF6}.png]]

خوب حالا ما این رو توی service ها اضافه کردیم حالا میرسیم به این که اضافه اش کنیم به pipeline  تا ازش استفاده کنیم 

![[{38E8593B-49BD-4505-A71B-A7CC09666173}.png]]

اینطوری میایم اسم اون policy که اون بالا تعریف کردیم رو میاریم و اینجا استفاده میکنیم 

![[{BEC0CEC1-94D9-424B-991E-E013928256BE}.png]]

توضیحات بیشتر 
https://andrewlock.net/making-authenticated-cross-origin-requests-with-aspnetcore-identity/

بعدا مطالعه شود 


خوب حالا میرسیم به serilog 

https://virgool.io/dotnetzoom/%D8%A8%D8%B1%D8%B1%D8%B3%DB%8C-%D9%88-%D9%BE%DB%8C%D8%A7%D8%AF%D9%87-%D8%B3%D8%A7%D8%B2%DB%8C-centerilzed-logging-system-%D8%AF%D8%B1-asp-net-core-%D8%A8%D8%A7-%D8%A7%D8%B3%D8%AA%D9%81%D8%A7%D8%AF%D9%87-%D8%A7%D8%B2-serilog-%D9%88-elasticsearch-%D9%88-kibana-jbevdsvooran

خوب logging توی پروژه خیلی مهمه ، مخصوصا برای api  ها چون توی api ها ما هیچ اینترفیسی نداریم که داره دقیقا چه اتفاقی میوفته برای همین یه موقع هایی که مثلا  client میگه که من فلان کار رو کردم و فلان ارور خوردم برای ما خیلی مشکل میشه که بخوایم track کنیم و مشکل رو پیدا کنیم 

خوب برای همین میخوایم یه چیزی رو ستاپ کنیم که log ها رو generate کنه و بهمون نشون بده که چه اتفاقاتی داره میوفته در هر روز و هدف بعدی اینه که بیایم همه این log رو ذخیره کنیم  

میایم این رو نصب میکنیم :
![[{7F1C122E-7E8B-40E5-9EFB-E23F7C8D8845}.png]]
خوب همچنین یه مفهمومی داریم به اسم sinks که میاد اون فایل خروجی رو بیاد کجا و به چه صورت ذخیره و Save کنه 

![[{76368DE9-4472-40D6-8362-ACB16BA0C7D5}.png]]

که برای این پروژه میایم و seq رو نصب میکنیم و ازش استفاده میکنیم 

![[{394FE2CA-5C77-4837-89B3-E36197043464}.png]]
https://satyampushkar.medium.com/serilog-logging-to-console-seq-elasticsearch-file-using-dotnet6-d9536b534209

این رو نصب میکنیم :
![[{6A340A69-7C4B-4FD1-9DE0-51DEA9798CC7}.png]]

بعدش میایم serilog expression رو نصب میکنیم برای cofig کردن در پروژه 
![[{B37EEF02-B429-4BE0-A872-39ABECA6E022}.png]]

و در csProj نشون میده که چیا نصب کردیم :
![[{47809D7B-E788-4CAE-AF56-D3D21CD82971}.png]]

خوب این نکته هستش که وقتی که اسم این پکیج ها اینجا باشه خوده vsisual studio میره اون ها رو دانلود میکنه و میاره برای اجرای پروژه 

![[{0058E461-C9B3-4431-8FA7-D1EB02D73626}.png]]

https://andrewlock.net/exploring-dotnet-6-part-2-comparing-webapplicationbuilder-to-the-generic-host/

خوب اینجا نوشته که قبلا فقط مشید برای web/http استفاده بشه ولی تیم .net اومده کاری کرده که از worker service ها بتونیم استفاده کنیم برای message queus و grpc , windows serivce 

این کار با هدف این که web app با قابلیت configureation و loggig و di رو با برنامه هایی با type های دیگه دراه هم بتونیم انجام بدیم 


![[{04BCE564-E63A-4606-B530-DE3E729E08CF}.png]]

https://andrewlock.net/exploring-dotnet-6-part-2-comparing-webapplicationbuilder-to-the-generic-host/

![[{2FB91A21-9909-4808-9BDC-C24D74A0664A}.png]]

![[{5430D2FE-8085-4E60-8783-2CF94850900E}.png]]



![[{EE7EBB0D-D652-41FA-A0D6-8C8AF0CE9FC0}.png]]


![[{7119B74B-6856-45D7-9537-0B694187F8A9}.png]]

![[{CBD0F245-F562-424A-89C6-ED285EB8F3FF}.png]]

![[{FEEBAE53-4C1A-43FF-8580-5F81F96B31F4}.png]]

![[{83741ADB-E354-4BF9-B34C-E77D4CBD3309}.png]]

خوب اینجا توی app setting میبینیم که فرآیند logging به صورت دیفالت تعریف شده و ما برای این که بخوایم از serilog استفاده کنیم میایم این رو پاک میکنیم 
![[{488CC388-C9E9-4877-A85A-7B07AFD6BFBE}.png]]

![[{E0F8AE85-571B-411D-A11B-2BF7B3842D37}.png]]

![[{BFC8AA6A-6A55-4439-8AE5-9F6B8DE56D01}.png]]

![[{0F33D5CD-B1A5-457E-9A91-35271EE21FF3}.png]]

![[{E5C2ACC1-E655-48CC-AD13-7966AB17A503}.png]]


![[{418B2DD3-28D8-44A1-9C41-88A542B3C4D1}.png]]

خوب ما اومدیم اول روی سیستم warning ماکروسافت اومدیم override کردیم اون تنظیماتی رو که میخواستیم و بعد اومدیم تعیین کردیم که کجا save بشه اطلاعاتمون و بعد هم اومدیم گفتیم که میخوایم از seq برای ذخیره سازی اطلاعات استفاده کنیم 

خوب برای استفاده از Seq میریم و دانلودش میکنیم از سایتش فقط این مورد هستش که سایتش از اونور مارو تحریم کرده 


![[{664277DA-5647-4DE2-BE1B-F499DEBAF12F}.png]]

![[{7C128989-266A-4381-808C-84BBBB6703E3}.png]]

![[{2F25AFE6-5FEE-4FF2-89BE-ABCAC145112F}.png]]

![[{80A1F5B7-4835-4563-B156-3F68D412846F}.png]]

خوب ما به طور مثال شاید بخوایم یه مدل customiziation رو انجام بدیم برای نمایش لاگ هامون برای همین میایم از یه middlewate استفاده میکنیم 

![[{670336C6-F713-47D0-A601-981A99BFE06A}.png]]

قبل از useHttpsRedirection میزاریمش 

حالا میریم سراغ data base 

![[{A9ECC6D1-60B3-4111-B9A6-17C2B8501189}.png]]


![[{E9BC9406-CA09-48C3-9FCD-43E96B21E3E4}.png]]

اینجا میتونیم ببینیم که با اون پکیجی که نصب کردیم چه چیزهای دیگه ای باهاش نصب شدن 

![[{BF249DE3-9F95-49F3-96D6-68C0902DF56B}.png]]


خوب حالا اینجا میتونیم تعیین کنیم و بنویسیم که اسم سرورمون چیه 
![[{80304695-19F7-45F3-915D-046309DFB668}.png]]
اگر سرور روی سیستم خودمونه که local میشه اگر روی سیستم دیگه است که ip اش رو میدیم ، اگر توی یه instace دیگه روی سیستمون هست ، اسم اون رو مینویسیم 

![[{FDC3AE05-0E2C-4357-87E7-E469887101D5}.png]]

 خوب اینجا trusted connection رو true گذاشتیم که بگیم connection که داریم مورد اطمینان هستش و مورد بعدی که multipleActiveResultSets هم این قابلیت رو بهمون میده که به صورت همزمان از چند جا به این app وصل بشیم 

خوب حالا ما این رو اینجا تعیین کردیم حالا باید بریم توی program و به برنامه بگیم که از این استفاده کنه برای ef Core 

![[{E7180978-2409-4832-8899-50451985327C}.png]]
خوب اینجا یه var رو تعریف میکنیم و بعد میریم اون connection string رو میاریم و میریزیم داخل متغییر ConnectionString برای این که وقتی که خواستیم از دیتابیس استفاده کنیم این رو بهش بدیم 

بعد اومدیم سرویس AddDbContext رو اضافه کردیم و با استفاده از option بهش گفتیم که داریم از sql server استفاده میکنیم و بعد هم بهش connection string رو دادیم  

![[{BAE7574A-CEA9-42C4-B56D-8E0A764F6DDA}.png]]
خوب اینجا ما اومدیم توی کلاسی که ساختیم توی constructor اش اومدیم از DbContextOption در آرگمان ورودیش استفاده کردیم که اون options که اونجا هستش در حقیقت از همون options که در program نوشتیم داره میاد  

![[{CDAD541D-F1DC-4ABC-8182-2A140606E1DB}.png]]

بعد از این که options رو گرفتیم میاریم پاسش میدیم به base چون context به این option برای initilize شدن به این روش نیاز داره 

خوب بعدش یه کلاس میسازیم و فیلد id رو براش تعیین میکنیم ، وقتی که ef core این پترن رو میبینه متوجه میشه که id فیلدیه PK هست و  auto inctimental هستش  

![[{08684993-A53B-4747-BE3A-54D49EE2D866}.png]]
هم به شکل بالا متوجه میشه و هم به این شکل 
![[{5C602456-CE4B-4541-8308-8671E60279D3}.png]]


![[{516A24FB-A101-41C0-B6D3-DA7F59B681A0}.png]]


![[{C6D5EB6B-BB66-4FB6-864E-C284C654B97B}.png]]

![[{1877ED9B-00BA-43CD-94B6-942B4BA05FB3}.png]]
به هر دو حالت میتونیم بنویسیم ولی مزیت پایینی اینه که دقیقا اسم همون فیلدی رو که میخوایم رو بهمون به شکل string بهمون میده و هر وقت که اسم اون فیلد رو تغییر بدیم بهمون ارور میده ولی در مورد بالایی اینطور نیست و هیچ اروری نمیگیرم و بعدا در برنامه دچار مشکل میشیم 


![[{FF820F0D-8838-41D3-9B6E-706E91D146CF}.png]]

![[{CBF41238-C265-4DCC-9B9C-7770010E0DB7}.png]]

![[{6E734EF8-8FB1-4BF7-BC3A-20B4FCD8617F}.png]]

  

خوب اینجا ما تعیین کردیم که CountryId به عنوان FK و اینجا ef با توجه به convention که هست متوجه میشه که این FK متعلقه به Country چون CountryId نوشتیم Country + Id

 ![[{AB606B1A-542B-4D26-8091-48A756997690}.png]]

![[{75CC9229-696E-4F56-ABB0-46E75EA48F9C}.png]]

و اینجا ما یک ارتباط یک به چند و چند به یک داریم 

خوب حالا بعد از اینها 

![[{41D8BF77-EB79-457F-85FA-D98C126E62AA}.png]]
به ارور این که این فیلدها نمیتونن null باشن برمیخوریم و برای رفع این ارور میایم 

![[{06B5700F-D7E3-412F-B125-C9FBE57F02C8}.png]]
میایم و nullable رو disable میکنیم 

بعد میایم و توی کلاس که رابط با دیتابیسمون رو ساختیم کلاس هایی که میخوایم ازشون استفاده کنیم رو معرفی میکنیم ، اینطوری:
![[{0ADC3D03-E2E4-455D-BE85-DE9B1ECCD49A}.png]]

![[{EDF8279A-F172-41E9-B202-1EC1D19D62A9}.png]]

![[{B770FA17-AF20-4051-AE41-46633AAABBCC}.png]]

خوب اینجا به این ارور برخوردیم وقتی که Add-Migration InitialMigration رو زدیم:

![[{6279A3E1-A3EF-40CD-A644-3873D016D3E8}.png]]

توی خط آخر نکته ای که گفته مشکل ما رو حل میکنه ، این که باید Options رو به base  بدیم 

![[{ECD6557E-29A0-4DC3-B230-7FAE4377DA81}.png]]

خوب اینجا در فایل migration این ها رو میبینیم 

![[{9EB80C27-84E5-4E74-A507-62CE3E2CF3F1}.png]]

به طور مثال میتونیم cascade رو تغییر بدیم ، معنی cascade در اینجا اینه که اگر Hotels رو پاک کنیم دیتاهای County هم پاک میشه 

خوب اینجا یه بخشی داریم به اسم up که یعنی اون کاری که میخوایم انجام بدیم و اعمال کنیم و قسمت down میشه قسمتی که بخوایم undo کنیم تغییراتی که اعمال کردیم 

![[{6A45DB36-9830-4BCC-8DAD-71369B460935}.png]]

![[{D93C743F-A74F-402D-9701-9C0C981621F5}.png]]
![[{8B8B0584-0FB8-42FC-B652-888F3B997653}.png]]
یه راه دیگه هم برای دیدن دیتابیس استفاده از 

![[{64294517-1D2B-4789-AAAE-14C1C93AB70F}.png]]

![[{037A9A90-040A-42BD-BA85-E93BA2E52941} 1.png]]

توی قسمت server مینویسیم localdb/mssqllocaldb 

حالا میخوایم دیتابیسمون رو  seed  کنیم :

![[{D54DC356-D8A2-4B1F-8E9D-66D9ED50A77D}.png]]

![[{B8DF8384-B44B-48E0-9051-41B9DC5EF9B9}.png]]

![[{D3E24E34-533C-429A-89C9-7618267CC425}.png]]

![[{A18E1E82-0DC8-4559-8670-3746F4A49CE2}.png]]

خوب اول میایم country رو به دیتابیس seed میکنیم چون هر کدوم از هتل ها به این کشور ها وابسته هستند و هر هتل باید این رو داشته باشه 

![[{08B3787A-B178-4ED1-A369-4D928A025273}.png]]

به همین ترتیب میایم هتل ها رو هم اضافه میکنیم و بعد هم add-migration و بعد هم آپدیت رو میزنیم و این دیتا ها رو وارد دیتابیس میکنیم 

خوب در مرحله بعدی میایم برای درست کردن controller و میایم از scaffolding این کار رو انجام میدیم 

![[{C7ACF4AB-9FDB-42AF-AF35-891B031D2155}.png]]

و بعد اینطوری بهمون یه صفحه نشون میده که میایم با این اطلاعات پرش میکنیم و جالب اینجاست که خودش بر اساس اون های میاد یه اسم پیشنهادی رو میزاره برای کنترلر

![[{5E60045F-5D36-4A62-97AA-6324672B0002}.png]]

اگر اینجا به ارور خوردیم دلیلش میتونه این باشه که پکیج هایی که داریم استفاده میکنیم از یک ورژن یکسان نباشند و این باعث ارور میشه 


اینجا هم اومدیم db contrxt رو به عنوان یه service اومدیم  Register کردیم و همین کار به ما این قابلیت رو میده که بتونیم injection رو انجام بدیم توی هر جای برنامه که بخوایم میتونیم این کار رو انجام بدیم هر جایی که بخوایم ازش استفاده کنیم  

![[{69E0678F-249F-40CC-A418-B9C797C0CCB7}.png]]


![[{1E805A8F-0310-4A6C-A428-63525D69FBA6}.png]]

خوب اینجا اومدیم و توی constructor اومدیم کلاس مرتبط با database رو قرار دادیم و بهش اسم context رو دادیم و ریختیمیش توی یه پارامتر private 

با این کار دیگه نیاز نیست که بیایم و هر سری که خواستیم از دیتابیس استفاده کنیم بیایم و یه instance جدید بسازیم و همین که از injection استفاده میکنیم باعث میشه که کمک میکنه به life time عه context چون اینجوری توسط کل برنامه کنترل میشه و اینطوری میشه که هر وقت که Request بیاد و اون کاری که قراره با دیتابیس انجام بشه ، انجام میشه، برنامه میاد database instance یا database function رو که در background داره اجرا میشه رو kill میکنه  و اینطوری خیلی به بهبود memory و سرعت برنامه کمک میکنه 

![[{EBC31698-497D-44DB-9E5C-B7CBC3BD8C2B}.png]]

![[{53C443DA-5A27-4C36-AF97-BB2A21AFF397}.png]]

یه ارور خیلی عجیبی که خوردم این بود که من تمام این ها رو به ورژن 6.0.2 تغییر دادم یعنی پاک کردم و این ورژن رو ریختم ولی بعد از این که زدم یه کنترلر باسزه با همین روش خودش این ها رو تغییر داد 

![[{4DC71882-3754-47B1-A306-691018FDAC5B}.png]]

![[{4F9B9384-CD96-4E0E-A8D2-91FEC67BFCB4}.png]]

![[{DB259DB7-9539-4E23-9413-F9B49C34AE4A}.png]]

,وقتی که آپدیت هم کردم باز هم به ارور خوردم 

![[{DC6D6CF0-A96A-4627-BEE7-AE7E86F81D3A}.png]]

برگردوندم به حالت اول ولی همچنان ارور میده برای درست کردن کنترلر به این روش 

![[{792EB0BE-9370-4C97-9B91-C195EAD09ED1}.png]]

![[{4F676509-8B57-4D35-B478-0CF48978C4F3}.png]]
خوب entry برای فراهم اوردن دسترسی به اطلاعات و انجام عملیات روی اون هاست 

خوب state برای ست کردن state همون یک entity که در entry هستش و state بقیه entity  ها رو تغییر نمیده ، ولی در صورتی که state رو به delete , detach تغییر بدیم به صورت cascade روی بقیه entity ها تغییر ایجاد میکنه 

![[{08B9B8FC-C99D-4588-A042-E5E9AF77D4C3}.png]]

![[{BEDDFC12-969A-4ADF-A7FF-29612DB549F3}.png]]

![[{174F4E23-215B-4B9B-BC69-5104BD9D054F}.png]]

![[{381C586C-3191-4035-A521-40B0C0C7DD44}.png]]

![[{969690C2-2F5A-4D3E-BA6F-255B6AC1EA58}.png]]

![[{8A2E44AC-DFAE-4BEB-BF5D-0A22B3AAADB6}.png]]

![[{74A72874-0470-4A3F-B1FA-6063919F0A2F}.png]]


![[{76E4E87C-168E-42C4-936D-37961E7C4135}.png]]

اینجا ما وقتی که bracket داریم یعنی arry داریم و curly brace ها هم object هستش

![[{944979BA-E0DF-4EAB-8DF4-5EEB075160CA}.png]]

در جواب اینطوری میشه :
![[{1053598A-A595-4937-9711-EF6D063FB7D3}.png]]

خوب از خط اول اینطوریه که توی request url وقتی که نوشته api/countries به خاطر اینه که خودمون این رو براش تعیین کردیم 

![[{2195736B-1E69-47C9-A94D-4D4FF1519677}.png]]


خوب توی قسمت response header 

![[{62995864-62F7-4C63-A1BC-68FA2CC888C4}.png]]
و توی قسمت Response body 
![[{4DD702DB-F8E9-4F11-BCA6-D170D0752730}.png]]

این به خاطر نوشتن 
![[{64DCE5CD-EC0D-42EC-899F-DF4EB334EA55} 1.png]]
چون اومده id که 4 هستش رو با route بهمون داده و خوده آجکت country که در response body اومده و ما این رو اومدیم آخر  created at action نوشتیم که country رو برگردونه 

خوب مشکلی که داره اول اینه که ما نباید خودمون id رو تعیین کنیم و ارسال کنیم 

نکته: اگر 0 بزاریم خوده ef میفهمه که باید بهش مقدار بده و این کار رو برامون انجام میده 

![[{1A15CC90-1CF1-4523-BAB2-78AE9F7BD9BA}.png]]

![[{28281B83-47F5-4BD9-916E-2016B2B4AAFD}.png]]

خوب حالا توی قسمت get اگر بخوایم خیلی مشخص کنیم که جوابی که قراره ارسال بشه از چه نوعه میایم اینطوری تعیینش میکنیم:

![[{7D8C59D0-3019-4A90-9360-CE363AAE1CD7}.png]]

اینطوری بهمون مشخصا 200 رو برمیگردونه 

![[{36C7926E-E65B-4598-A294-AB0A62FEF647}.png]]

نکته :
![[{855B09B6-CAA4-4CD1-AC60-601B89973CB0}.png]]
اگر ما اون قسمت مسیر id رو پاک کنیم اتفاقی که میوفته اینه که swagger که کلا میپوکه و اتفاق بعدی که میوقته اینه که توی postman هم request بفرستیم 404 به ما میده با ارور ambigous match exception که این یعنی این که وقتی که یه درخواست میاد این درخواست میتونه به چند تا End point بره و اون ها رو فعال کنه ، که همین قضیه باعث ارور میشه 

![[{672D8BF1-AC5F-4BD6-A865-89ABF8B6C8BC}.png]]

![[{04253AC5-14A0-429E-BCD7-CB62A96CDAFA}.png]]
![[{E8636DE3-FF6E-4103-B2EE-FE983C88EC01}.png]]
توی ارور postman  هم نشون میده که این request به دو تا end point  میرسه 


میرسیم به put : کاری که put میکنه اینه که کل دیتا رو هر چیزی که ما نوشته باشیم رو همش رو برمیداره و میبره میزاره جای اون دیتایی که الان هستش، برای همین هم هست که آرگومان های ورودیش فقط یدونه id میگیره و کل اون object رو 

داشتن id دلیلش اینه که بره و چک کنه که اشتباهی به جای یه دیتای دیگه آپدیت رو انجام نده 

یعنی میاد id رو با id که داخل country هستش چک میکنه   

![[{546AF388-F498-4597-A2DB-A8355BE1F5BC}.png]]

![[{4DBD0215-03D9-4C29-BAA0-3E06BF49EF29}.png]]
میتونیم برای ارور 404 که میفرسته یه پیام هم بنویسیم  

نکته : هر entity یک State داره که اینطوری تعیینش میکنیم :
![[{16EA96EB-A7EB-466E-BE59-4458A16DF0A6}.png]]

![[{C9346CAD-B802-4C9D-A5C9-81FBD0AACF77}.png]]
با تغییر state داریم یه Ef میگیم که این دیتایی که داریم ارسال میکنیم دیتایی نیست که بخواد جایی اضافه بشه یا حذف شه یا هر چیزه دیگه ای ، این دیتا یک دیتای آپدیت هستش و دیتای جدید که بخواد به کل دیتابیس اضافه بشه نیست و عملیات وقتی تکمیل میشه که saveChangesAsync اعمال بشه .

خوب دلیل این که اومدیم save changes رو توی try catch گذاشتیم اینه که اگر زمانی به علیت این که چند تا یوزر بخوان به صورت همزمان یه دیتایی رو تغییر بدن و اگر این اتفاق بیوفته exception اتفاق میوفته و اگر این اتفاق بیوفته میایم اول چک میکنیم ببنیم اصلا اون دیتا وجود داره یا نه ، ممکنه قبل از تغییر ما نفر دیگه اون رو پاک کرده باشه 

خوب اگر ما نتونیم catch کنیم میایم و no content  رو برمیگردونیم که یعنی عملیات انجام شده ولی دیتایی نیست که برگردونم 

خوب اینجا id که داریم ارسال میکنیم با id اون کشور یکسان نیست 

![[{DC3C6725-4CD8-423C-ACE6-79C8712ACC4F}.png]]

![[{B634014A-5E18-4653-BB1E-7100A397703A}.png]]
بعد id درست رو ارسال کردیم :
![[{5CBE8C21-574C-441F-ACE7-8ADDCCC56678}.png]]
نکته اینه که no content از نوع 200 هستش 

خوب اینجا اگر مسیر رو تغییر بدیم به این ارور میخوریم :
![[{47A90A0B-AFFC-445D-8595-2A053D99D066}.png]]
![[{072EB581-8238-46E4-9712-F2032CB22B32}.png]]

این یعنی این که اصلا همچین متدی نیست که بخوام برم و ازش استفاده کنم 

خوب حالا میرسیم به delete 
![[{935C475F-6240-45FD-9332-CB70261B41AC}.png]]

این جا هم میایم اول میایم id رو میگیریم بعد میریم میاریمش میزیمش توی country و بعد میایم state اش رو تغییر میدیم و بعد میایم عملیات رو انجام میدیم .


نکته : اینجا با استفاده از any میایم و تمام دیتابیس رو چک میکنیم و میبینیم که آیا همچین id وجود داره یا خیر 

![[{CDA0F004-50B7-430F-8034-918ACC6628E9}.png]]

![[{42805635-9F86-4D6D-AB51-806D35BC9F0D} 1.png]]

![[{0532DE92-CA93-4343-8E9B-9B8917EB1B61}.png]]

خوب یه مشکلی که داریم اینه که over posting داریم یعنی از سمت client دیتاهایی که میره سمت سرور زیاده و به طور مثال clinet نباید خودش id رو بتونه بفرسته و این یه مشکله و برای حل کردنش میایم از DTO ها استفاده میکنیم 
![[{7DB3A425-C137-4F11-AE96-ACB390C72B28}.png]]


و وقتی که DTO نداشته باشیم swagger چیزی که به ما نشون میده اینه که همه این فیلد ها رو میتونیم مقدار براشون تعیین کنیم و بفرستیم :

![[{F88E5ACE-B439-4980-8B81-8FCD3B37EC9F}.png]]

خوب DTO ها میشن یه abstraction از اون دیتایی که میخوایم بفرستیم 

خوب توی پروژه یه فولدر درست میکنیم به اسم Models که توش میایم و تعیین میکنیم که دیتاهای توی برنامه باید چجوری باشن 

  خوب ما میخوایم از سمت یوزر فقط name , ShortName رو بفرسته 
![[{2AA5D8FD-5BD6-4663-BC50-8974113022D8}.png]]

![[{DCBF2998-89FA-4D04-AE8B-E1EA903253FE}.png]]
خوب حالا توی postman وقتی نگاه میکنیم میبینیم که اینطوری شده :

![[{A41E60A6-C99A-4698-882E-D597D1385F26}.png]]

ولی همچنان در response این رو برمیگردونه :
![[{3D0125DA-65F7-4D0D-83B7-724678F26450}.png]]

نکته : ما میایم و دوباره با id میفرستیم Request رو ، اتفاقی که میوفته اینه که سرور اصلا دنبال id نیست و اون رو اصلا نمیبینه و براش فرقی نداره که چه عددی ارسال شده ، چیزی که براش تعریف شده name , short name هستش 
![[{F42589B3-AC58-4F90-BD02-6682A2B5C6DB}.png]]

خوب حالا اگر نیاز به چک کردن داشتیم اینطوری مینویسیم :

![[{ED034924-EF9C-4673-8E4D-AA85BE68F062}.png]]

خوب وقتی که با postman بیایم Req بزنیم 

![[{D809F0E6-D6CF-4776-95CB-78D79487327E}.png]]
اینطوری جوابش میشه 
![[{572C9E01-2158-4F73-9BD3-24ED924192D1}.png]]

![[{03B40B18-8B88-4436-B8D9-123AF75EAC03}.png]]

![[{7280E345-C9C6-45CD-8B97-6410D71596ED}.png]]
بعدش میایم از profile ارث بری میکنیک که برای خوده auto mapper هستش و بعدش میایم و توی constructor ازش استفاده میکنیم برای این که بیایم بین data type ها maps درست کنیم 

حالا این یعنی چی؟ یعنی این که auto mapper به ما این قابلیت رو میده که بیایم CreateCountryDto رو به Country وصل کنیم که دیگه نیاز نباشه اینطوری به صورت کد بنویسیمش:

![[{0119EFF8-8328-4E5B-A4C2-9D3CF5EA98B6}.png]]

خوب 
![[{22E2CEEB-BFEC-47E3-837C-726FCC53F879}.png]]
اینجا ما اومدیم Country رو به CreateCountryDto مپ کردیم و این کار رو میتونیم به در یک جهت یا برعکس یا برای هر دو اعمال کنیم که با نوشتن reverseMap برای هر دوتاشون اعمال میشه یعنی Country به CreateCountryDto و بلعکس انجام میشه 

خوب حالا ما باید بیایم به برنامه مون هم بگیم که ما داریم از Auto mapper استفاده میکنیم و برای این کار باید auto mapper رو به صورت یک injectable resourse برای controller هامون درست کنیم که هر جا که خواستیم هم بتونیم ازش استفاده کنیم 


خوب حالا برای این قضیه میایم اینطوری تعریفش میکنیم :
![[{309042EE-4A07-4E0E-8EBF-9C9CC862AA72}.png]]
بهش اینجا داریم میگیم که Configuration که میخواد استفاده بشه توی برنامه از طریق auto mapper  توی این کلاس تعریف کردیم 
 ![[{BA99C912-FAB6-458A-B861-8AC14F446D43}.png]]

خوب حالا مزیت استفاده از auto mapper اینه که ما ممکنه یه جایی 20 تا فیلد داشته باشیم و نوشتن به صورت دستی این همه فیلد زمان میبره ولی auto mapper این کار رو برای ما خیلی راحت انجام میده 

حالا برای استفاده کردن ازش توی controller مون باید بیایم اول inject اش کنیم  

![[{AA732A62-77C9-4B3F-B00D-BC9AB298F91D}.png]]
اینجا به جای قسمت بالا از auto mapper در خط پایینیش استفاده میکنیم 

![[{4172CB86-3594-4C5A-9A54-6A13B9B38EEA}.png]]


![[{70032341-EB50-428F-B219-B00825F6BFA0}.png]]
![[{6077B3E8-088D-405A-BAB2-F1C25F742896}.png]]

اینجا داره میگه که اول ما auto mapper رو کانفیگش رو اول درست میکنیم که این کانفیگه میاد وصل شدن پراپرتی ها رو بین دو تا کلاس تنظیم میکنه یا اگر نیازه که تغییراتی توی این وصل شدن رو ها اونجا مینویسیم و تنظیم میکنیم  و بعد با دستور map عملیات رو انجام میدیم 

خوب حالا میخوایم get رو refactor کنیم چون که موقعی که ما دستور getCountries رو میدیم 

![[{E5E5B5A8-684C-4E4B-8A9D-723F3C744AB7}.png]]
تمام اینها رو به کاربر میده که این درست نیست و برای حل این مثله میایم یه DTO دیگه براش تعریف میکنیم 

![[{5C6FD832-ABAF-46CA-967F-7A4054CBEE47}.png]]

اینجا ما چون نیاز داریم برای عملیات دیگه مثلا پاک کردن و ادیت کردن، که id رو داشته باشیم برای همین id رو گذاشتیم بمونه و لیست هتل ها رو از توش حذف کردیم 


![[{87D99BF2-E560-4154-A054-46D54815E856}.png]]


![[{B602B95A-C2F7-4175-8391-4734A9C66895}.png]]
خوب اینجا میایم اول لیست و کالکشن تمامی کشور ها رو میگیریم در مرحله ی بعدی نمیتونیم یه کالکشن رو به یه آبجکت DTO بیایم و map کنیم و باید اینجا از IList یا IEnumerable استفاده کنیم  

![[{8771DFE8-2D87-4543-900E-A9D558B57F33}.png]]

خوب حالا میخوایم قسمت GetCountry که با id هستش رو ریفکتور کنیم و برای این کار  میتونیم از DTO های موحود استفاده کنیم یا بیایم و یکی دیگه تعریف کنیم  

نکته : auto mapper میاد با استفاده از naming convetion ها میاد و آبجکت ها رو بهم map میکنه ، به طور مثال تمام پراپرتی های GetCountryDetailsDTO به Country وصل میشه ، از جمله Hotels

![[{F6CE6E33-ADEF-42DF-AE27-C1103B6A4C33}.png]]

![[{DD2D3644-1232-4B11-9C65-517710B88BEA}.png]]


فقط قانون مهمی که داریم اینه که ما نباید هیچ وقت نباید هیچ DTO رو داشته باشیم که به صورت مستقیم به دیتا یا data model مون وصل شده باشه و DTO ها فقط با DTO ارتباط پیدا میکنن و تنها جایی که DTO ها با دیتا Cross path دارن جاییه که عملیات mapping انجام میشه   

نکته : DTO ها حتی نباید یک فیلد داشته باشند که مستقیم به دیتا بخواد وصل بشه 

مثل اینجا 
![[{B3C7CB53-E4F9-46C6-A20F-B4716DF76482}.png]]
و برای همین هم هست که ما اومدیم توی GetCountryDetailsDTO هتل ها رو با یه DTO دیگه که مرتبط با هتل ها هستش وصل کردیم نه خوده Hotel


خوب حالا میخوایم وقتی که با id درخواست رو فرستادیم اسم هتل هایی که توی این کشور هستند رو برامون بیاره :

![[{B6CD97DD-5C7D-4E8B-BC17-BA0546230275}.png]]

![[{620A6BC7-8FEA-4561-9D5E-46A9999CBC67}.png]]
ولی بهمون null میده و برای حل این مشکل باید یه refactoring انجام بدیم :

![[{4193DA01-3326-4D17-A19A-5A13B97C14B4}.png]]
خوب ما وقتی که نوشتیم include  اومدیم گفتیم که کشور رو میخوایم + هتل هایی که داخلش هستند این کار در دیتابیس معادل inner join هستش که ما در اینجا اومدیم جدول country رو با جدول hotel با هم inner join زدیم تا اطلاعات هتل هایی که توی اون کشور هستش رو بدست بیاریم  

![[{8EEA35EE-D59F-415D-AE50-BE4102E5A1F2}.png]]

خوب در مرحله ی بعد که first or default هستش هم اومدیم گفتیم که اون دیتایی که با اون id یکسان هستش رو بردار برای ما بیار اگر هم هیچی نبود که هیچی

![[{07FF46F6-E1D0-49C3-872E-5F897DE9C857}.png]]

![[{4C74C2F2-8759-4831-B40B-5E57631D51C3}.png]]

نکته : اینجا ما توی dto که برای hotel تعریف کردیم خوده آبجکت Country رو دیگه نیاوردیم چون اونطوری Recursive میشد

خوب حالا به این قضیه میرسیم که میخوایم برای put هم یه dto تعریف کنیم ، خوب نکته ای که اینجا هست اینه که خیلی از این DTO ها در یک سری از فیلد ها یکسان هستند ، پس میایم و کلاس از نوع abstract میسازیم 

![[{43B8CF79-EAF1-4821-BB59-187C22ED4D50}.png]]

و بعد اینطوری ازش استفاده میکنیم :
![[{BD31636A-F115-44DF-9C20-0558E24D28EE}.png]]
نکته اگر به طور مثال ما توی کلاس base اومدیم و برای name در نظر گرفتیم که required باشه بهتره که در کلاس هایی که ازش ارث بری میکنن نیایم تغییرش بدیم چون میره روی کلاس base و override میشه 

یا به بیان دیگه vallidation rules ها باید universal باشن در کل پروژه 
نکته ی بعدی اینه که حتی وقتی که ما Reqired در نظر گرفتیم این قضیه توی Get کردن دیتا تاثیری نداره 

نکته با control + . یه سری آپشن به ما میده 

خوب ما تمام این کار ها رو برای این انجام میدیم که seperation of concerns رو انجام بدیم که یکی از اصول Solid هستش 

![[{1A6A8D5A-ACE0-4C7D-AEC2-017835CDE828}.png]]

خوب اینجا اومدیم و اول با استفاده از Id دیتای country رو اوردیم و ریختیم توی country و بعد با استفاده از mapper__ اومدیم و بعد update Country Dto  رو دیتاش رو گرفتیم و بعد باهاش دیتای توی country رو آپدیت کردیم 

![[{C23CCC4E-CD5F-498A-A6F2-811E98519F0A}.png]]

وقتی که دیتا رو از دیتابیس داریم میاریم اون رو track کردیم و وقتی که track اش کردیم و بعد تغییر روش ایجاد کردیم باید state اش رو تغییر بدیم و بعد هم save اش کنیم 

خوب اون خط ای که mapper رو نوشتیم داره دیتایی که داخل UpdareCountryDTo هستش رو میزه توی country و بعد به صورت اتوماتیک به ef میگه که این دیتا تغییر داده شده و دقیقا مثل همون تغییر state این کار رو به صورت اتوماتیک میکنه 

خوب حالا میرسیم به repository pattern 
هدف اینه که یک level abstraction بین کنترلر و intelligence ایجاد کنیم که اینجا intelligence به معنی همون business logic هست که توی کنترلمون نوشتیم و خوب ما نمیخوایم توی کنترلرمون بیایم خیلی به  decision making بپردازیم ، داخل کنترلر باید جایی باشه که فقط request رو دریفات کنه و جوابش رو بده 

به کنترلر باید به چشم manager نگاه کنیم و این به معنی اینه که لازم نیست همه ریز جزییات رو بدونه 

خوب میایم و دو تا فولدر درست میکنیم به اسم های Repository و Contracts ، که Contracts میشه abstraction  class  , و Repositiory میشه کلاس پیاده سازی 

 خوب اینجا یه اینترفیس میسازین و این اینترفیس میاد به شکل یه قانون و قرارداد عمل میکنه و force میکنه چه چیزهایی باید انجام بشه 

![[Pasted image 20250113132047.png]]

خوب اینجا T به معنی data object مون هستش که ما با نوشتن where : class داریم تعیین میکنیم که از جنس کلاس هستش و در اینجا یعنی Hotel , country میشه 

و IGeneric Repository مسئول ارتباط با دیتا بیس هستش 

دلیل این که generic در نظرش گرفتیم اینه که نخوایم یه سری از query ها رو تکرار کنیم چون وقتی که داریم کار میکنیم یه سری اتفاقات تکراری ممکنه که پیش بیاد - اصل  DRY

![[{43D22284-573A-4261-A897-BDDA772BB774}.png]]

خوب دلیل این که این رو به شکل generic نوشتیم اینه که میخوایم تفاوتی نداشته باشه که که این کارها برای country میخواد انجام بشه یا برای Hotel 

![[{F489D5CA-18DC-445C-8E2E-9C708804A194}.png]]
خوب حالا یه interface نوشتیم که از IGenericRepository ارث بری کرده و اونجا به جای T دیگه اینجا تعریف کردیم که این اینترفیس مرتبط با country هستش و باید این کار رو انجام بدیم 

خوب ما توی IGenericRepository تمامی قانون های که کلی هستند رو مینویسیم و بعد میایم هر کدوم رو با جزییاتشون توی قراداد های متفاوت مینویسیم 

 خوب حالا بعد از قرارداد میریم سراغ اصل کار که تعریف کلاس اصلی GenericRepository هستش 
![[{59865DFD-665F-47EE-B0CD-A2C65528D2CB}.png]]

و بعد از این که ساختیمش اومدیم از Interface که براش درست کردم ارث بری کردیم  
نکته اینه که اون فلش های آبی کوچولو که اون بقلن مارو میبرن به جایی که ازشون استفاده شده یا ازشون ارث بری شده 

 ![[{0EAA6F85-999F-435C-928A-544546A95020}.png]]

خوب حالا میایم شروع میکنیم که repository رو درست کنیم 
![[{F41AC861-CCEA-42A6-B215-C5AF987C2433}.png]]

![[{2C94D12E-1552-4929-8C6E-F9A840E63E7F}.png]]

اینجا اومدیم از async استفاده کردیم و بعد از AddAsync استفاده کردیم که این متد میاد entiy که بهش در آرگمان ورودی میدیم رو میگیره و Ef core اینجا متوجه میشه که اون entity که از جنس T  بوده دقیقا چیه یعنی الان داره Hotel وارد اون entiy شده یا country و این رو با استفاده از AddAsync و قابلیت های Ef core بدست آوردیم 

ولی در این حالت ما باید مشخصا تعیین کنیم که چیه 

![[{9619093B-4751-4CF8-8F12-0F2577B70FBF}.png]]
یا اینجا که دقیقا نوشیتم و بعد add رو زدیم 

![[{8E14EF8B-F9CB-4737-A1D3-09E8C24F418C} 1.png]]
حالا اگر بخوایم مثل همون حالت generic بخوایم ازش استفاده کنیم (تست شود)

![[{F461BDDC-1210-4F62-93DD-B3902FEA02BD}.png]]

![[{BC44CF98-602C-4CE9-BEAA-DB14EB0085FB}.png]]

![[{C9E4B88B-0328-4CCD-8470-7C51155C8CE7}.png]]

خوب نکته ای که هست اینه که تا زمانی که to list async اجرا نشه اتفاقی نمیوفته و وقتی که اجرا میشه میره و اون DBSet رو میاره و query رو اجرا میکنه و تمام دیتاها رو میاره 

نکته عملیات remove به صورت لحظه ای انحام میشه یعنی نمیتونیم از async استفاده کنیم ولی میتونیم save changes رو به صورت async انجام بدیم  

![[{40669BA1-F480-4ADC-8873-0B9E296738ED}.png]]
![[{FCF4D11B-6397-4506-90E1-A20660C3D29B}.png]]

![[{D2C06FF9-4C9E-440A-B96B-118A06729C30}.png]]
![[{F04F0807-A199-4CEC-A13B-5F63A2B659C4}.png]]
![[{05337F1F-3F38-4F75-A3E0-BF6C0844C7CE}.png]]
خوب اینجا اومدیم یه CountriesRepository درست کردیم که کار های مرتبط با country و دیتابیس رو انجام بده و برای این کار میایم ازGeneric Repository و ICountryRepository ارث بری میکنیم 

![[{0115021E-C65A-4600-A2C8-99AC0ED6275F}.png]]
خوب ما یه قرار داد برای یا همون اینترفیس برای country نوشته بودیم که اینجا میایم ازش ارث بری میکنیم که خوده اون اینترفیس هم از اینترفیس IGeneric Repository که مشخصا از country داره استفاده میکنه ارث بری میکنه :
![[{81A3C434-01DB-4172-8D01-7F28587A818C}.png]]

خوب با ارث بری کردن ICountries Repository و GenericRepository میتونیم هر کاری رو بین Countries Repository و Generic Repository رو انجام بدیم

خوب حالا اگر بخوایم یه کاری رو با counry انجام بدیم میریم توی اینترفیس ICountry repository تعریفش میکنیم و بعد میتونیم بیایم توی Country repository پیاده سازیش میکنیم 

کاری که کردیم این بوده بوده که اینترفیس Country از generic ارٍث بری کرده و خوده Country هم از Generic Repository Country ارث بری کرده و اینطوری ارتباط بین این دو تا برقرار شده 

خوب حالا اینجا یه نکته ی خیلی خیلی مهم داره :
![[{3A24F6EC-C81D-49C7-B5DB-A331CC2AC964}.png]]
![[{C30F230C-037D-406E-A15B-7C0994491A4B}.png]]

![[{579EBF57-D410-448C-8B2C-44F6BAEED43E}.png]]
خوب حلاصه ی متن بالا اینه که ما فقط از یه جا وصل به صورت مستقیم وصل میشیم به دیتابیس و بقیه کلاس هایی که از همون اصلیه مشتق میشن باید از Base ارٍث بری کنند. چرا ؟ توی این متن توضیح میده :

![[{304C1D8A-1F24-425C-84CE-C67961E679CE}.png]]

![[{9A2B4108-E635-4F08-ADC8-B922FED295F2}.png]]

![[{D4709BBD-0764-4631-A540-866C30C31395}.png]]

نکته قسمت 3 اینه که میگه که قبل از این که کد داخل constructor کلاس Countries Repository اجرا بشه runtime میاد constructor base class generic repository رو با context اش میاد Call میکنه 

قسمت 4 ام میگه که توی constructor generic repository اتفاقی که میوفته اینه که context_ با context پر میشه 

قسمت 5 میگه که بعد از این کار در constructo base class انجام شد Controls میاد اون رو به constructor countries repository برمیگردونه و اونجا ما میتونیم یه سری تنظیماتی که مربوط به کشور هستش رو اونجا انجام بدیم 

![[{C2401552-5D32-4FD6-9B42-2994DD586139}.png]]
![[{2AC21EA4-1CD6-4A9D-A838-07D819219C42}.png]]

نکته ی بعدی : 

![[{14D2BA42-F970-49E7-A226-E75116662C94}.png]]

خوب حالا اینجا میایم توی controller اصلی و اینجا حالا میخوایم از repository استفاده کنیم :
![[{CA0D6242-7138-4B4D-A39B-B1BB461DD801}.png]]
بعدش به این صورت میشه :
![[{DE1A502F-0970-4F55-9DD1-E17C125AEE3C}.png]]

خوب این مورد رو باید دقت داشته باشیم که ما هر جایی از ICountry Repository استفاده کردیم ما اومدیم از IGeneric Repository که مشخصا با تایپ Country هستش ارث بری کردیم 

![[{71B1E855-269C-4FE7-83C2-E0C7A1204135}.png]]
![[{6D9EAD92-E00D-4750-AC5E-973DCA3EE738}.png]]
 پس هر جایی اومدیم ازش استفاده کنیم ، مشخصا داره Country رو پیاده سازی میکنه 
![[{EC9FE487-34D4-4135-8824-04793476CFC1}.png]]

مثل عکس بالا که مشخصا میخواد بره و لیست تمامی کشور ها رو بیاره 

خوب اینجا اومدیم و GetAllAsync رو اول در اینترفیس تعریف کردیم و بعد اومدیم توی Generic Repository پیاده سازیش رو انجام دادیم و بعد اومدیم با استفاده از ارث بری که اینترفیس ها Generic و متد های اجرایی Generic میتونیم از این ها استفاده کنیم. 

![[{4474BD58-CFDC-4D26-A79E-F995F1D5A3E7}.png]]

![[{11AE3B4E-285B-46FB-ABF6-5BA6FFA35608}.png]]

خوب حالا به طور مثال اینجا اول میایم id رو میگیریم و بعد عملیات delete رو انجام میدیم :
![[{252432F9-B419-4430-9A4B-AD756F77F545}.png]]

خوب حالا اینجا میخوایم از Exitst استفاده کنیم :
![[{C6071D20-6B0B-42AC-A04D-410D2520B21F}.png]]

![[{C79ACACD-74BC-42E4-9CF9-A97E4A87282F}.png]]


![[{264287C4-8B9E-4ABD-9490-B806AE06407A}.png]]

![[{2B89258C-9BFD-47DD-BCD1-D0A719469C6E}.png]]

خوب حالا میرسیم به موردی که خاص هستش و مشخصا برای Country هستش و میخوایم الان تغییرات رو روش اعمال کنیم :

![[{84194934-A108-462C-9305-CD47565F334F}.png]]

اینجا میخوایم اسم و مشخصات کشور + Hotel ها رو بیاریم که این مشخصا و فقط برای Country هستش 

اینجا ما نمیتونیم از این متد استفاده کنیم، چون در این حالت فقط id رو میدیم و مشخصا اون کشور رو میگیریم و دیگه اسم هتل هایی که توی اون کشور هستش رو نمیتونیم ببینیم ، برای همین باید یه متد خاص برای این کار بنویسیم  
![[{E54506D9-9290-438A-989F-62E4EB9176FE}.png]]

 برای همین اول میایم توی اینترفیس ها تعریفش میکنیم 

![[{148D4405-1F87-4E30-A0E2-44E0FF2AF54D}.png]]

![[{B7564E0E-CDD5-46A1-87AD-3000647F6E35}.png]]
نکته: اگر اینجا first or default نتونه اون Id رو پیدا کنه null برمیگردونه 

![[{D9501C35-985A-4C42-912C-EA96A51C3380}.png]]

 خوب اینطوری ازش استفاده میکنیم .

اینجا به این ارور برخوردم وقتی که توی swagger زدم روی get
System.MissingMethodException

![[{9266BF69-AEAA-4ABB-9745-2917A7FA1612}.png]]

![[{68C303E3-9508-471D-AAEE-0540CF8F250A}.png]]

![[{B1AF8C9D-CC8D-4D11-8A69-02AC77E76572}.png]]

خوب در حین اجرای پروژه به این ارور خوردم و وقتی که چک کردم دیدم که یه سری از پکیج هایی که مرتبط با ef هستش یه سریشون که مرتبط با scafolding بوده آپدیت شده و بقیه همون ورژن قدیمی هستن که همین باعث ارور شده بود 

خوب اینجا هم داستان به همین صورته که اینجا هم باید از DTO ها استفاده کنیم به این دلیل که به طور مثال اینجا ما وقتی که GetHotels رو زدیم بهمون داره کشور رو هم میده و داخل اون کشور باز هم Hotels هستش که خودش میشه Recursive و برای جلوگیری کردن از این قضیه میایم و از DTO استفاده میکنیم 


![[{D9B8D49C-9AB8-4A38-B7C4-16E68DEC25F5}.png]]

البته وقتی که request میزنیم این رو تحویل میده :
![[{C0E7B0A5-5E80-4474-A180-BCFC44CC9506}.png]]

خوب اینجا برای این که به ارور نخوریم برای این که این مقدار double میتونه null باشه و خالی باشه یه نه میایم از ؟ استفاده میکنیم 
![[{45ED07F0-A551-400C-8EB5-DEC841417A0D}.png]]

نکته ی بعدی 
![[{02767FB0-B9C0-452F-8FC2-2089F0651FE3}.png]]

اینجا ما میخوایم اطلاعات رو از دیتابیس بگیریم و به کاربر نشون بدیم ، اینجا ما میایم اطلاعات رو از دیتابیس میگیریم و بعد تبدیلش میکنیم به صورت DTO و بعد به کاربر نشونش میدیم و برای همین از اون مدل map استفاده میکنیم 

![[{FDE0A5F0-F4C1-4F54-9FD0-A4EBB8A482F7}.png]]

در این حالت ما میخوایم اطلاعات رو از کاربر دریافت کنیم میایم اون به فرم DTO دریافتش میکنیم ولی برای این که بخوایم این اطلاعات رو توی دیتابیس بفرستیم باید به شکل اصلی خودش باشه بنابراین میایم اون dto رو به شکل اصلی دیتا که hotel هستش درمیاریم 

خوب توی دو تا عکس بالا از map به دو شکل متفاوت استفاده شده :

![[{433974B0-2A1D-431B-B889-C30E82F78829}.png]]


![[{7400D53E-CBD5-43E3-9B66-CC1186F1255E}.png]]


![[{71420BD4-ADF7-4089-B6C4-D62A9229A787}.png]]

میرسیم به قسمت api secuity 

خوب یکی از راه های امن کردن api اینه که بیایم بر اساس ip دسترسی به ip رو درست کنیم 

یه راهش اینه که برای هر کسی که میخواد به این api دسترسی پیدا کنه بیایم و یوزر پسورد بدیم و هر موقع که میخواست ازش استفاده کنه بیاد و user password رو وارد کنه ولی مشکل از اینجا شروع میشه که اگر توی هر درخواست Api بخواد برای دسترسی بیاد و هر سری که درخواست میاد اون رو چک کنه و اطلاعاتش رو از روی یک دیتابیسی چک میکنه که ببینه این یوزر اصلا دسترسی داره یا خیر ، و بعد اگر دسترسی داشت از یه دیتابیس دیگه بیاد و اون درخواست رو اجرا کنه که خوده این پروسه یک بار زیادی رو روی سیستم اضافه میکنه.

یه راه دیگه اش api key access هستش که شبیه به همون مورد قبلی یعنی basic authentication هستش و اینطوری عمل میکنه که میگه یه کدی داریم که هر سری که میخوایم درخواست بدیم میایم اون رو هم باهاش میفرسیتم ولی همون کلید هم که میفرستیم هم باید بیایم و چکش کنیم ببینیم که اوکی هست یا نه 
یه راهی که معمولا برای درست کردن این کلید ها انجام میشه اینه که همون مشخصاتی که توی basic auth استفاده کردیم ازشون رو encode میکنیم و اون رو به شکل یه کلید در میاریم و با درخواستمون میفرستیم و اون سمت توی سرور باید این کلید بیاد و Decode بشه و پروسه ی Validation check روش انجام بشه 

یک بدی دیگه ای که داره اینه که هر کسی که این کلید رو بدست بیاره میتونه به جای یوزر اصلی بیاد و یه درخواست رو Spoof کنه 

مورد بعدی استفاد از jwt هستش اینطوریه که یه توکن با یه محدودیت زمانی هستش و بعد از این که تایمش تموم شد دوباره درست میشه 

خوب حالا سوالی که پیش میاد اینه که فرق این مورد با مورد قبلی چیه؟

اول این که این web token ها قرار نیست خیلی اساسی secure باشن و اطلاعات حساس هم نباید توشن باشن

ولی توشون یه چیزی به اسم claims رو قرار میدیم که هر یوزی برای دسترسی باید اون ها رو داشته باشه 

خوب اول این که هر یوزری با user , password وارد میشه و authenticate روش انجام میشه و بعد از اون بهشون توکن میدیم و هر وقتی که خواستن درخواستی بزنن اون توکن رو باهاش میفرستن و وقتی که اون درخواست رو گرفتیم میایم دیکدش میکنیم و میبینیم که آیا اون اطلاعات پایه که تمامی یوزر های برای دسترسی باید داشته باشن رو داره یا خیر 

چیزهایی که قراره ازش مطمئن بشیم اینه که بفهیمیم که از سمت سرور خودمون درست شده باشه و این که مطمئن بشیم که توسط خوده کلاینتمون ارسال شده 

و به این توکن ها هم یه طول عمر 30 دقیقه ای میدیم 

خوب حالا برای این کار ها میایم و از identity استفاده میکنیم :

![[{46DC528A-4DA3-478C-9861-ECD1302436AA}.png]]
اولی identity user که میاد یه یوزر رو تعریف میکنه و خودش یه سری چیزها رو مثل email , شماره تلفن و user name ,  password و encription رو همه رو با هم به صورت built in داره و میتونیم خودمون هم custumize اش کنیم ولی داستان زیاد داره ،  

خوب قسمت بعدی که identity role داره اینه که اینجا میتونیم تعریفش کنیم که اون یوزر چه کار هایی رو بر اساس اون role که داره میتونه انجام بده 

و بعد تعیین میکنیم که از کدوم دیتابیس برای این کار ها استفاده میکنیم با استفاده از Add Entity framework stores و بعدش تعیین میکنیم که کدوم دیتابیس رو میخوایم استفاده کنیم  

  ![[{1610C79C-E821-44A6-83C6-713BC5FB60EC}.png]]
  

![[{59CFE550-403A-49EC-96AD-E5184D46A74D}.png]]



![[{95C0702F-24FA-4EA1-8617-341C46757EB0}.png]]

![[{A3132002-2B3C-473C-B3F5-12B84260A748}.png]]

خوب حالا به طور مثال میخوایم first name و last name رو به idenity user اضافه کنیم 

خوب برای این کار میایم یه کلاس میسازیم از identity user ارث بری میکنیم  

![[{4AA14884-EEC4-4ACA-979C-2E0DF84E74A6}.png]]

حالا توی program  میایم identiy user رو عوض میکنیم :
![[{EC93D8D8-9267-421C-8096-11F964AFE22B}.png]]

خوب حالا ما اینجا تعریف کردیم که از این دیتابیس برای identity استفاده بشه ، وقتی که این کار رو کردیم حالا میایم کلاس HotelListingDbContext رو میایم ویرایش میکنیم و به اون هم میگیم که قراره به عنوان Identity db context هم ازش استفاده بشه :

![[{A1287F2F-DFF3-4364-B6CA-EEF8C98F13AC}.png]]


![[{F2BBAF05-5CAC-4353-8B23-AC432938D2C5}.png]]

![[{ABA6186D-63B2-4C09-B0E7-D79A54EF5822}.png]]


خوب بعد از این که تغییرات رو انجام مدیم migration رو انجام میدیم 
![[{CE37E822-21C9-4D72-BA54-FD9E2BC2A2B9}.png]]
خوب حالا میرسیم به قسمت تعریف role ها 

![[{3E979743-F272-43F4-BA57-81727B8D8159}.png]]
در اینجا میخوایم تنظیمات مرتبط با role ها رو تعیین کنیم برای همین یه کلاس به اسم role configuration ساختیم و برای این کار باید از IEntityTypeConfiguration قسمت Identity role ارث بری کنیم 

![[{6AB949E4-8F96-4B88-8D22-04DE6D67562E}.png]]

خوب حالا اینجا میایم این config که تعریف کردیم رو میبریم و به dbcontext اضافه اش میکنیم :

![[{CB9C7D77-2E55-4C75-AEB8-D21CF602D81D}.png]]

نکته راجع به base.OnModelCreating
![[{915D4549-CA57-41E9-9842-E3B8CC6EF8DE}.png]]
![[{026500C8-9FD8-436D-BFBF-543B9A6A3AA9}.png]]

![[{7427811D-5CCE-487A-8331-17E9AFD72609}.png]]

برای country هم میتونیم استفاده کنیم :

![[{E48FC636-9651-4090-9D92-D8B26A33CE7D}.png]]
خوب بعد از این که این کار های رو انجام دادیم میایم و migration رو انجام میدیم و اونجا میبینیم که فقط دو تا role که تعریف کرده بودیم به قسمت up اضافه شده 

![[{BEA9A022-9E8A-4579-9902-886C7CCDB659}.png]]


خوب حالا میایم داخل دیتابیس رو نگاه میکنیم 

![[{98CAF870-6236-4625-A81B-6751F8277B3C}.png]]


![[{63E1E2D0-5B6D-4445-8488-CEF84BE298C1}.png]]
نکته به صورت دیفالت چیزی که password validation خوده .net چک میکنه اینه که password باید حداقل یک حرف کوچیک و حداقل یک symbol , حداقل یک عدد و نمیتونه کمتر از 7 تا کارکتر باشه  

![[{B5288544-57F0-4878-B870-EAC24842AEA6}.png]]

خوب حالا  ما میایم این رو به شکل که میخوایم custumize میکنیم 

![[{24BE1C04-7934-4B78-A520-3E707582E08A}.png]]
خوب اینجا میایم از UserManager در constructor استفاده میکنیم 

![[{6A377125-D511-4A02-85A4-67DD3E44256C}.png]]

  خوب حالا میخوایم وقتی که یه یوزی خواست ثبت نام کنه اگر به مشکل خورد بیایم ارور رو بهش نشون بدیم برای این کار میایم از Identity error استفاده میکنیم :
  ![[{8C632F60-7E85-4F44-9646-6CB11A170734}.png]]
   دلیل این که IEnumerable استفاده کردیم به خاطر اینه که ممکنه چند تا ارور داشته باشیم اگر خالی باشه که هیچی

 نکته : وقتی که یک یوزر رو درست میکنیم باید  باید بهش آدرس ایمیل و username بهش اختصاص بدیم و این جز رفتار default identiy core هستش 

خوب حالا اینجا به همین دلیل باید تعیین کنیم که آیا همون ایمیل تبدیل بشه به user name یا   بیایم و user name رو جدا از email تعیین کنیم 

![[{5E53F88C-255C-416E-AF7F-C9F950827583}.png]]
  خوب حالا اینطوریه که ما اول دیتایی که میخوایم رو با استفاده از ApiUserDto از کلاینت میگیریم و بعد میایم اون دیتایی که گرفتیم رو با استفاده از  auto mapper به Api User تبدیلش میکنیم 
![[{C0CA4118-AEC2-485E-B2AF-5DF9501A5FD9}.png]]
که توی api یوزر علاوه بر فیلد هایی که خوده identity user داره ، اومدیم و بهش دو تا فیلد جدید رو هم اضافه کردیم 

بعد طبق قوانینی که بالاتر گفته شده و اینطوری بود که باید به جز ایمیل username رو هم تعریف کنیم اینجا username رو با ایمیل یکی کردیم و در مرحله ی بعد میایم با user manager create async میایم اطلاعات یوزر رو میگیریم و پسوردی که وارد شده رو به صورت hash شده درمیاریم حالا اگر این عملیات موفقت آمیز بود میایم با استفاده از Add to role async اون رو به role که میخوایم اضافه میکنیم که اینجا تعیین کردیم اون role از نوع user باشه 

در مرحله ی بعد چون ما توی Return داریم ارور ها رو برمیگردونیم ، میایم میگیم که اگر اروری اتفاق افتاد بیاد اون رو برگردونه 

![[{29F1DFDF-B162-4580-A2D5-B75FA87F748F}.png]]

![[{A82F9C72-6775-4F03-9792-542E4434921C}.png]]

نکته patch برای update به صورت target ای هستش ولی put کلی آپدیت رو انجام میده و متفاوته 

![[{F900E05E-E34D-411F-9E09-3A894AF6CD10}.png]]
خوب اینجا تعیین کردیم که میخوایم اطلاعات رو از سمت کلاینت به سرور بفرستیم و میخوایم post رو انجام بدیم و براش یه مسیر تعیین کردیم و بعد با استفاده از attribute سوم تعیین کردیم که ممکنه این عملیات جوابی که میده ممکنه bad request باشه و اینطوری اون کسی که توی فرانت کد میزنه میتونه یه سری اطلاعات از این که چه اتفاقی ممکنه بیوفته رو میفهمه و این رو توی swagger نشون میده 

![[{4CB9FD48-E1FA-4952-9986-73326BDADA56}.png]]

![[{4F69BD5A-8279-4D2E-B73B-9C2E2743C151}.png]]

نکته ی مهم : اینجا وقتی که پروژه رو run میکردم بعد از هر request که میزدم این ارور میومد 

```csharp
System.ArgumentException: GenericArguments[0], 'System.Char', on 'T MaxFloat[T](System.Collections.Generic.IEnumerable`1[T])' violates the constraint of type 'T'.
 ---> System.Security.VerificationException: Method System.Linq.Enumerable.MaxFloat: type argument 'System.Char' violates the constraint of type parameter 'T'.
   at System.RuntimeMethodHandle.GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation)
   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)
   --- End of inner exception stack trace ---
   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)
   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)
   at AutoMapper.Internal.TypeDetails.<>c__DisplayClass25_1.<GetPublicNoArgExtensionMethods>b__10(MethodInfo extensionMethod)
   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()
   at System.Linq.Enumerable.ConcatIterator`1.MoveNext()
   at System.Linq.Enumerable.SelectManyIterator[TSource,TCollection,TResult](IEnumerable`1 source, Func`2 collectionSelector, Func`3 resultSelector)+MoveNext()
   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()
   at System.Linq.Enumerable.UnionIterator`1.MoveNext()
   at System.Linq.Enumerable.ConcatIterator`1.MoveNext()
   at AutoMapper.Internal.TypeDetails.PossibleNames()
   at AutoMapper.Internal.TypeDetails.GetMember(String name)
```

https://support.aspnetzero.com/QA/Questions/11423/Test-upgrade-to-NET-7---Method-SystemLinqEnumerableMaxFloat-type-argument-%27SystemInt64%27-violates-the-constraint-of-type-parameter-%27T%27

با سرچ زدن رسیدم به این سایت که توش نوشته بود علت این ارور به خاطر ورژن 11 auto mapper هستش و در ورژن های بعدی برای .net 7 این قضیه رو درست کردن :
![[{86EB96C5-EEE7-4B6C-B566-D643CA987D89}.png]]

![[{2E8AF993-F100-4C3A-9F3E-443CF4661535}.png]]

خوب حالا میرسیم به قسمتی که میخوایم login کنیم برای این قضیه میایم یه dto جدا درست میکنیم :
![[{61A6CF06-F434-46B7-BC1B-470E120650F0}.png]]
که api user dto از این dto ارث بری میکنه و بعد میایم توی اینترفیس IAuthManager متدی برای log in کردن تعیین میکنیم و بعد میایم در Auth manager پیاده سازییش رو انجام میدیم 

![[{943614C8-E598-479A-9CEB-39DEEC773FA0}.png]]
![[{C02586E1-2F27-4D22-BF62-E3087BDA6ACA}.png]]
 ![[{407415EB-F458-4320-BA75-9C094CD58A8E}.png]]
 
 
 خوب حالا اگر اتفاقی که بیوفته این باشه که null بیاد توی user  که این باعث exception میشه 

نکته : وقتی که متغییری نشون میده که task<> یعنی این که ما درست منتظر اون object نشدیم یعنی از await استفاده نکردیم 

![[{43361666-E019-44D6-B262-6E32F41E4C38}.png]]

اینطوری درست میشه :
![[{E591BE50-477A-43E9-B6B9-325504FD4004}.png]]

![[{8B54ABE3-7E44-4BFC-A62A-FEC3A15C8225}.png]]
![[{FFB09B44-512A-4028-9DB7-213E721AC94F}.png]]

خوب اینجا کاری که کردیم این بوده که اگر null اومد و exception اتفاق افتاد کل api خاموش نمیشه و فقط false رو برمیگردونه 

خوب ما یه پروسه دیگه به اسم sign in کردن رو هم داریم که با کاری که داریم انجا انجام میدیم متفاوته و توی sign in اتفاقی که میوفته اینه که cooke و session و کار های دیگه هم انجام میشه ولی اینجا نه 

ولی api ها sateless هستند 

خوب log in فقط میاد چک میکنه که ببینه که user در سیستم هست یا خیر 
و یه فرقی که api با یه web app داره که توی Web app یه cookie میتونیم درست کنیم یا یه کارهایی میتونیم بکنیم که ارتباطمون با اون یوزر و کلاینت حفظ بشه  و Session مون حفظ بشه و از طریق اون بفهمیم که کی داره ازش استفاده میکنه 
 ولی api ها stateless هستند و نمیدونند که چه کسی و چه زمانی قراره ازشون استفاده بشه و به همین دلیل هم هر بار که بخوایم یه درخواستی رو ارسال کنیم باید log in کنیم که میتونیم با راه هایی این رو بهترش کنیم  خوب یه راهش اینه که این دسترسی و ارتباط رو از طریق log in میتونیم بهتر کنیم و مدیریتش کنیم و این کار رو میتونیم از طریق jwt ها انجام بدیم 


![[{7BEF7F0B-9393-421E-A33A-D7A716E81ECF}.png]]

![[{CC66CBA1-150D-479A-A324-E94544929919}.png]]

![[{5FFB4D8B-E934-4EB3-90EA-DE02A26B1604}.png]]

اول authentication انجام میشه و بعد authorization انجام میشه 

![[{4BF40F63-4FE6-4D26-A71C-7FA667D82574}.png]]
![[{DDE84AFA-2F27-480D-BB8C-480848C314C1}.png]]

خوب ما به جای استفاده از magical string اومدیم از jwtBearerDefaults.authenticationScheme استفاده میکنیم  

![[{7089E3E2-DC53-40A2-A8E0-0956D6B20067}.png]]

![[{7BC145A5-B809-466E-890B-0F257D1FF6F4}.png]]

![[{9893C8B4-32D1-45DB-A474-3AC17D5541CB}.png]]

![[{6068D5BD-F468-4CC2-B0AF-6FF04E5EE8B0}.png]]

![[{F89C4B1E-16B4-467C-8425-402628EAC6A8}.png]]

![[{41E1708A-56EE-47D6-8E09-D503D7A6E0BB}.png]]
برای این که بخوایم امنیت یه داده رو بیشتر کنیم میتونیم توی یه قسمت دیگه به اسم UserSercrets بزاریم :
روی پروژه کلیک راست میکنیم و بعد میزنیم روی manage user secrets اینجا هم دقیقا شبیه به configuration file هستش ولی به صورت secret 

![[{7415C50F-E1A3-4104-9C99-855E2E860031}.png]]