![[Pasted image 20241208132354.png]]

مثلا کارت به کارت کردن توی لایه use case قرار میگیره چرا که عضوی از bussinse logic 
خوب همونطوری که میبنید دیتابیس به عنوان آخرین و بیرونی ترین لایه به عنوان فیچر برای پروزه در نظر گرفته شده 
اصلی ترین جا بر اساس معماری ddd میشه دامین ما و بعدش اپلیکیشن و بعد دیتابیس
باید اصلا برنامه طوری طراحی بشه که با یه دیتابیس in memeory یا هر مدل دیتبیس دیگه بتونه کار کنه 

![[Pasted image 20241208132412.png]]


![[Pasted image 20241208132417.png]]


توی domain میایم entity هامون رو مینویسیم و توی application اون سرویس هایی که قراره از این ها استفاده کنه 
در لایه persistence میایم دسترسی به لایه هامون رو پیاده سازی میکنیم 
در لایه infrastructure چیزهایی که خارج از پروژه مون هستش و میخوایم ازش استفاده کنیم رو قرار میدیم و این چیزها مربوط به بیزینس اصلی نیستش 
ارسال ایمیل و چیزهای دیگه 

نکته ای که هست اینه که لایه بیرونی و بالاتر میتونه از اطلاعات لایه های پایین تر استفاده کنه ولی لایه های پایینی نمیتونن از اطلاعات لایه های بالایی استفاده کنند 


![[Pasted image 20241208132439.png]]



خوب حالا راهش چیه اگر بخوایم این کار رو انجام بدیم 
این که بیایم از یک قرار داد و اینترفیس برای ارتباط با لایه بالاتر استفاده کنیم 

![[Pasted image 20241208132459.png]]


مثلا برای استفاده کردن application از لایه ی بالاتر که میشه context باید بیایم یه اینترفیس رو تعریف کنیم که بتونیم از context استفاده کنیم 
ما توی application نیاز داریم که از دیتابیس اطلاعات بگیریم و یه سری اطلاعات رو روش ذخیره کنیم 
البته این که گفتیم application نمیتونه از لایه persistance استفاده کنه به خاطر قواعد clean arc هستش 

این یعنی databasecontext از dbcontext ارث بری کرده و باید هم اینترفیس IdatabaseContext رو پیاده سازی کنیم 

![[Pasted image 20241208132513.png]]


خوب حالا میتونیم با استفاده از Idatabase context بیایم و از دیتابیس استفاده کنیم 
نکته : وقتی که متدی رو در اینترفیس پیاده سازی میکنیم باید در کلاس هایی که ازش استفاده میکنند هم پیاده سازییش رو انجام بدیم

![[Pasted image 20241208132532.png]]

ولی توی این قضیه چون متد save changes در db set قرار داره نیازی نیستش که ما این کار رو انجام بدیم چون یک بار ارث بری dbset رو انجام دادیم و میتونیم ازش استفاده کنیم 

برای این که بخوایم متد هایی save changes رو بدست بیاریم میایم یه بار توی خوده database context متد های save shanges رو میایم override میکنیم و بعد همون ها رو میبریم میزاریم توی اینترفیسمون که بتونیم از طریق اینترفیسی که اون هم دسترسی به dbcontext داره با دیتابیس از هر جایی بتونیم ارتباط بگیریم و بتونیم با استفاده از این اینترفیس دیتاهای خودمون رو سیو کنیم داخل دیتابیس 

![[Pasted image 20241208132558.png]]

خوب حالا میخوایم connection string خودمون رو بفرستیم برای database context میایم به صورت dynamically میخوایم این کار رو انجام بدیم تا هارد کد نشه ، خوب برای این کار میایم اول یه متد constructor درست میکنیم 


توضیحات برای 
![[Pasted image 20241208132621.png]]

این نسخه ی کد بالا در EF 6 به بالا کار نمیکند و نسخه ی کد پایین کار میکند 

![[Pasted image 20241208132636.png]]

اینجا ما از base استفاده کردیم چون base میشه constructor کلاس Dbcontext که ما اینجا میخوایم یه چیزیش رو تغییر بدیم و بهش یه options رو اضافه کنیم و وقتی که این کار رو بکنیم باید بهش یه سری پارامتر های جدید بدیم تا کار کنه 
حالا دقت کنید که ما اومدیم constructor کلاس Dbcontext رو تغییر دادیم و بعدش اومدیم دوباره توی constructor کلاس خودمون یعنی DatabaseContext ازش ارث بری کردیم و میخوایم بهش بگیم که قبل از این که بخواد اصلا اجرا بشن هر دوتاشون این تغییرات توی اصل کلاس ها ایجاد بشن و بعد ادامه برنامه انجام شود.

خوب یه داستانی که خوردیم اینه که ef6 با ef core فرق دارن 

![[Pasted image 20241208132652.png]]

این ویدیو رو باید حتما ببینم

https://www.youtube.com/watch?v=vdhFw1VSowg
![[Pasted image 20241208132726.png]]