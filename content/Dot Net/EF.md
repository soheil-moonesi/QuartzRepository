![[Pasted image 20250128111544.png]]

![[Pasted image 20250128111622.png]]


![[Pasted image 20250128111725.png]]

![[Pasted image 20250128111742.png]]
![[Pasted image 20250128112241.png]]
![[Pasted image 20250128112630.png]]

![[Pasted image 20250128180253.png]]
![[Pasted image 20250128180316.png]]

![[Pasted image 20250128180332.png]]

![[Pasted image 20250128180838.png]]

وقتی که Id میزاریم به صورت اتوماتیک میشه PK
وقتی که string میزاریم میشه var char حالا از مدوم نوعش رو در دیتابیس تعیین میکنیم 
![[Pasted image 20250128181703.png]]
وقتی که اسم جدول رو میزاریم و بعد id میزاریم اون هم یه convention هست برای PK

وقتی که میخوایم کلاس پایه بسازیم اون رو از نوع abstract میسازیم ، وقتی که abstract باشه دیگه نمیشه ازش instansiate کرد یا یک نمونه ساخت ، ما اون رو میسازیم که ازش ارث بری کنیم برای کلاس های دیگه 

![[Pasted image 20250128184755.png]]

![[Pasted image 20250128184823.png]]

![[Pasted image 20250128185508.png]]

خوب اینجا وقتی که داریم از db context ارث بری میکنیم یعنی یه کلاس معمولی رو تبدیل کردیم به کلاس ارتباطی که با دیتابیس در ارتباط هستش و قراره به جدول ها دسترسی داشته باشه 
در on configuring یه سری تنظیمات دیفالت هستش که ما میتونیم روش override کنیم 

در on model creating خوب اینجا وقتی که دیتابیس ساخته شد میاد نگاه  میکنه که روی field ها باید بیاد چی کار کنه یا چه sql رو اجرا کنه 

در قسمت آخر هم داریم جدول های دیتابیس رو میسازیم 

![[Pasted image 20250128185720.png]]

![[Pasted image 20250128190155.png]]

خوب ما از مجموع team ها در جدول ها Teams رو داریم برای همین این مدلی اسم گذاری کردیم 

این جا هم اون چیزهایی که میتونیم override کنیم رو میبینیم :
![[Pasted image 20250128190457.png]]
![[Pasted image 20250128190632.png]]

![[Pasted image 20250128190705.png]]
![[Pasted image 20250128191051.png]]
از on configuration برای set کردن connection strings استفاده میکنیم ولی بهترین راهش استفاده از secret هستش  

![[Pasted image 20250128191708.png]]
خوب توی on configuring میایم و base.onConfiguration رو پاک میکنیم چون داره تنظیمات اولیه رو تنظیم میکنه 

وقتی که داریم از VS استفاده میکنیم به دیتابیس داخلی دسترسی داریم :
![[Pasted image 20250128192030.png]]

![[Pasted image 20250128193533.png]]

اینجا از \\  استفاده کردیم که داریم اونجا آدرس رو تعیین میکنیم
خوب initial catalog اسم دیتابیسه 

![[Pasted image 20250128194318.png]]

![[Pasted image 20250128195029.png]]



![[Pasted image 20250128195307.png]]

توی migration ها میاد چیزی هست رو با تغییراتی که ایجاد شده مقایسه میکنه و فایل تغییرات رو آماده و تولید میکنه مثلا وقتی که دیتابیس نداریم اولین miration اینه که دیتابیس رو درست کنیم مثلا بعدش چیزی رو تغییر میدیم مثل این که یه فیلد رو اضافه میکنه میره و با ورژن قبلی چک میکنه و فایل جدید رو برای این تغییرات درست میکنه  
خوب up یعنی تغییراتی که باید به وجود بیاد و down هم یعنی چیزهایی که باید undo بشن 
خوب حالا هر تغییراتی هم که انجام میشه ef میاد یه جدول درست میکنه به اسم histoty و این تغییرات رو توش ذخیره میکنه 
![[Pasted image 20250128195814.png]]

![[Pasted image 20250128203745.png]]
![[Pasted image 20250128203759.png]]
وقتی که این کار رو کردیم توی فایل csproj فایل console مون 
![[Pasted image 20250128204303.png]]
این اضافه میشه 

![[Pasted image 20250128204931.png]]
دقت : کد بالا در قسمت db path مشکل داره و اون رو در بخش های جلوتر درست شده 
دقت:
![[Pasted image 20250128205232.png]]
ارور :
![[Pasted image 20250128211725.png]]
![[Pasted image 20250128211731.png]]
![[Pasted image 20250128231231.png]]
خوب اینجا نوشته که id از نوع auto increment تعریف شده
و قسمت name از نوع text تعیین شده در صورتی که این در sqllite هستش که اینوطریه و در sql server میشه n varchar max 
و بعد هم اومده کلید اصلی رو تعیین کرده 
![[Pasted image 20250128231324.png]]
اینجا نوشته شده که در صورتی که بخوایم undo کنیم چه  اتفاقی قراره بیوفته و نوشته که این دو تا جدول رو drop میکنه 

![[Pasted image 20250128231801.png]]

خوب در همین زمان که فایل migration درست میشه یه فایل snapshot هم درست میشه که میگه توی این تایم دیتابیس این شکلیه 

![[Pasted image 20250128235157.png]]
![[Pasted image 20250128235217.png]]
![[Pasted image 20250128235207.png]]

ارور حل میشه 
![[Pasted image 20250129001101.png]]

![[Pasted image 20250129001120.png]]


![[Pasted image 20250129003613.png]]

خوب حالا وقتی که دیتابیس از قبل باشه و بخوایم باهاش با ef  کار کنیم باید از چیزی به اسم scaffolding استفاده کنیم و مهندسی معکوسی رو انجام بدیم یعنی بیایم از روی ساختار دیتابیس رو بگیریم و بعد بیایم روش کارهایی رو که میخوایم رو انجام بدیم البته این روش داستانی که داره اینه که هر سری بخوایم از دیتا بیس و ef توی این حالت بخوایم استفاده کنیم باید از scaffolding استفاده کنیم 

خوب توی این حالت وقتی که بخوایم هر بار scaffolding رو اجرا کنیم میگه که این چیزی که میخوای همین الان هستش که ما این رو میایم با dash force درستش میکنیم 

![[Pasted image 20250129004619.png]]
اینجا توی کنسول باید برای آدرس از یک \ استفاده کنیم 
![[Pasted image 20250129004721.png]]
![[Pasted image 20250129004731.png]]
خوب آخر اون کامند که داریم مینویسیم اینه که تعیین کنیم از چه مدل دیتابیسی رو باید مهندسی معکوس روش انجام بدیم و اینجا نوشتیم sql server 

![[Pasted image 20250129005014.png]]

![[Pasted image 20250129005038.png]]
![[Pasted image 20250129005048.png]]

خوب از اونجا که زدیم -contextDir میخوایم تعریف کنیم که مهندسی معکوسی زدیم این اطلاعاتی که بدست آوردیم رو کجا بریزیم که براش تعریف میکنیم که کجا 

![[Pasted image 20250129005432.png]]
![[Pasted image 20250129005529.png]]
باید برای این که بخوایم دوباره اجرا کنیم این کامند رو از dash force استفاده کنیم 

![[Pasted image 20250129005953.png]]

توی این قسمت میبینیم که وقتی که از has data میخوایم استفاده کنیم خودش توی توضیحات نوشته اشاره داره میکنه به Array از Team ها 

![[Pasted image 20250129010233.png]]
وقتی که داریم Data seed میکنیم باید id اش رو بهش بدیم یعنی pk اش رو خودمون دستی تعیین کنیم 

![[Pasted image 20250129011058.png]]
وقتی که بیش از یکی دیتابیس و Context داریم باید بیایم موقع migration مشخصا اون رو بنویسیم 


![[Pasted image 20250129011249.png]]![[Pasted image 20250129011312.png]]

![[Pasted image 20250201113655.png]]
خوب برای مباحث آموزشی میایم از enable sensitive Data loggin, enable detailed errors استفاده میکنیم چون وقتکه ازشون استفاده میکنیم در مورد sensetive data میاد و دیتاهای حساس مثل password رو نمایش میده که مناسب نیست و فقط برای تست و مباحث آموزش استفاده میشه 

خوب ما وقتی که مسیر دیتابیس رو دادیم ولی باید بیایم توی جایی که console app هستش دیتابیس رو درست کنیم چون که cosnole app میاد اولین جایی که میگرده همون جاست و اگر نباشه ارور میده 

![[Pasted image 20250201114325.png]]
خوب اینجا داره در مورد local application data داره میگه که میشه همون آدرس جایی که پروژه هستش 

![[Pasted image 20250201115034.png]]
اول میایم آدرس جایی که پروژه هستش رو میگیریم و بعدش میایم اون آدرس رو با FootballLeague_efcore ترکیبش میکنیم برای ساخت و بعدش دسترسی به دیتابیس 

![[Pasted image 20250201123601.png]]
برای ساخت دیتابیس میایم اول پروژه cosole رو به عنوان start up در نظر میگیریم و بعدش با تعیین کردن پروژه ای که داخلش db context مون هستش و این دو تا بهم وصل هستند رو تعیین میکنیم و بعد migration رو انجام میدیم به این command دقت کنیم چون باعث ارور و ساخته نشدن migration میشه اگر اشتباه بزنیم مثل این ارور پایین 

![[Pasted image 20250201123804.png]]

![[Pasted image 20250201124722.png]]

![[Pasted image 20250201135344.png]]

این linq هستش و شبیه به sql برعکس هستش در حالت query syntax

تا زمانی که از to list استفاده نکنیم query اجرا نمیشه وقتی که استفاده میکنیم ازش میره دیتا رو میاره و بعد تبدیلش میکنه به C# object و میریزتش توی memory و اونموقع میتونیم ازش استفاده کنیم 

![[Pasted image 20250201144558.png]]


![[Pasted image 20250201144643.png]]
خوب در بالا میبینید که sql اجرا شده اینطوریه که دیگه از * برای این که همه دیتا رو بگیره استفاده نکرده و اومده فقط اون فیلیدی که میخواستیم رو اورده و بعد اومده از alising هم استفاده کرده 

عملیات های async جلوی thread block شدن رو میگیره ،    

یه نکته ای که هست اینه که مثلا اگر بیایم برای ذخیره سازی از save changes استفاده کنیم که async نیستش تا زمانی که دیتا اعمال نشه در داخل دیتابیس هیچی چیزی نمیتونه دیتابیس دسترسی پیدا کنه و thread block میشه 
![[Pasted image 20250201145454.png]]

![[Pasted image 20250201145546.png]]
خوب Ef از کارکردن به صورت موازی ساپورت نمیکنه 
و وایمسته یک عملیات تموم بشه و بعد عملیات بعدی رو شروع میکنه 
به همین دلیل میایم با استفاده از async و  awite میایم این رو براش طراحی میکنیم 

وقتی که از  using استفاده میکنیم فقط داخل همون scope هستش که میتونیم از اون پارامتر استفاده کنیم :
![[Pasted image 20250201161658.png]]
اینجا context به دلیل این که خارج از اون scope هستش ارور میده 

![[Pasted image 20250201161756.png]]
خوب در تصویر پایین 
![[Pasted image 20250201162757.png]]
اینجا اولی فقط میاد اولین مقدار رو از توی list تیم ها میاره و دومی میاد ، اولین تیمی که اون شرایط رو داره رو میاره مثلا اگر چند تا تیم داشتیم که id شون 1 بود  فقط اولیه رو میورد 

![[Pasted image 20250201163056.png]]

خوب حالا اگر در کد Sql دقت کنیم میبینیم که اونجا در آخر نوشته که limit 1 

خوب فرق firstAsync با firstOrDefaultAsync اینه که دومی رو وقتی که استفاده کنیم ، اینطوری میشه که اگر دیتایی رو نتونه پیدا کنه یا این که دیتایی نباشه مقدار null رو میاره ولی اگر از اولی استفاده کنیم و این اتفاق بیوفته ارور وارد سیستم میشه 
![[Pasted image 20250201163601.png]]
خوب در مورد بعدی :
![[Pasted image 20250201170701.png]]

خوب وقتی که single or default استفاده کردیم همونطوری که در Sql اش میبنید limit 2 داره ، چرا ؟ چون که اگر بیشتر از یکی دیتا پیدا کردن یعنی دوتا و اون ها رو اورد بعدش تشخصی میده که بیش از یکیه و ارور میده 

![[Pasted image 20250201170633.png]]
مورد بعدی 

![[Pasted image 20250201172807.png]]

![[Pasted image 20250201172844.png]]



![[Pasted image 20250202003523.png]]
وقتی که میخوایم متدمون رو به متد async تبدیل کنیم : متد باید از نوع task بشه و از async و awite استفاده کنیم 
![[Pasted image 20250202003510.png]]

![[Pasted image 20250202004124.png]]
هر جا نوشته بود predicate میشه همون lambda expressions خودمون 
![[Pasted image 20250202004240.png]]
هر جایی که اینطوری نوشته بود و یه سمتش یه تایپ بود و یه سمت دیگه اش bool بود میشه همون lambda expressions  

نکته : این کد پایین بدون to list هم کار میکنه ولی یه فرقی دارن ، اونم اینه که وقتی که to list رو ننوشته باشیم هر بار که میخوایم توی  team filterd بیایم iterate کنیم اون  میره و اطلاعات رو هر بار از دیتابیس میاره در صورتی که وقتی که از to list استفاده کنیم همون اول دیتا رو از دیتابیس میگیره و میریزه توی رم و بعد هر موقع بخوایم میتونیم ازش استفاده کنیم بدون این که دوباره بره دیتا رو بیاره 

![[Pasted image 20250202010015.png]]

![[Pasted image 20250202010026.png]]

![[Pasted image 20250202013601.png]]

![[Pasted image 20250202014154.png]]

خوب توی تصویر بالا ما میخوایم از یوزر اسم اون تیمی که میخواد رو بگیریم ، حالا اینجا اتفاقی که میوفته توی .net یه level از securityرو داریم که برای محافظت در برابر Sql injection درست شده و اینه که هر چی که وارد بشه paramteirized میشه 

![[Pasted image 20250202014429.png]]


نکته :
![[Pasted image 20250202084332.png]]
این دو تا با هم برابر هستند ولی این رو باید دقت داشته باشیم که بعضی از متد ها تبدیل به sql ممکنه نشن و یا دچار exception بشن 

![[Pasted image 20250202084341.png]]

اینطوری از contain استفاده میکنیم 
![[Pasted image 20250202084949.png]]
![[Pasted image 20250202084939.png]]


![[Pasted image 20250202104725.png]]

![[Pasted image 20250202105808.png]]

![[Pasted image 20250202105828.png]]

![[Pasted image 20250202110508.png]]

خوب اینجا اینطوریه که اگر چیزی توی شرط ننوشته باشیم یا شرط رو گذاشته باشیم یه string خالی این دستور میاد و همه ی دیتاهای موجود رو میاره، حالا اگر شرطی که گذاشتیم و  نتیجه ی اون instr بیشتر از 0 باشه میره و اون دیتا ها رو میاره 

![[Pasted image 20250202111122.png]]

![[Pasted image 20250202111253.png]]
https://www.w3resource.com/sqlite/core-functions-instr.php

![[Pasted image 20250202111342.png]]
![[Pasted image 20250202111353.png]]

https://www.sqlitetutorial.net/sqlite-functions/sqlite-instr/

خوب حالا ما میتونیم به جای استفاده از این روش بالا بیایم و مستقیم از Ef استفاده کنیم :
![[Pasted image 20250202114453.png]]

![[Pasted image 20250202143546.png]]
![[Pasted image 20250202143602.png]]

اینجا ما اومدیم و از @format استفاده کردیم و در خط بالاش مقدارش رو %F.C% رو گذاشتیم که % به معنای wild card هستند یعنی قبلش مهم نیست و بعدش هم مهم نیست که چی باشه هر جایی که F.C رو پیدا کرد بره و اون دیتا رو بیاره ، نکته بعد اینه که از like استفاده شده 
خوب با استفاده از Ef و like میتونیم بهتر و دقیق تر سرچ کنیم چون توی ef میتونیم پترن براش تعیین کنیم یعنی بگیم که با اون کلمه شروع بشه یا تموم به یا موارد دیگه 
![[Pasted image 20250202144152.png]]

اینجا نوشته که توی like اول جایی که قراره توش سرچ انجام بشه رو تعیین میکنیم که در این مورد name هستش و در آرگومان بعدی میاد و پترن رو میتونیم براش تعیین کنیم 

![[Pasted image 20250202150809.png]]
میتونیم به این روش که یجورایی شبیه به sql معکوسه متد ها رو به صورت hybrid استفاده کنیم ، به این شکل که ما اون رو داخل پرانتز نوشتیم و بعد از to list async استفاده کردیم 

![[Pasted image 20250202151333.png]]
![[Pasted image 20250202151355.png]]

 ![[Pasted image 20250202151626.png]]
 این با اون بالاییه یکیه نتیجه شون 
![[Pasted image 20250202152057.png]]
حالا min , max, avg, sum
![[Pasted image 20250202170158.png]]
![[Pasted image 20250202170144.png]]


حالا میرسیم به Count :
![[Pasted image 20250202161405.png]]

![[Pasted image 20250202161434.png]]
حالا میرسیم به group by :
![[Pasted image 20250202164448.png]]
اینجا اومدیم بر اساس create date گروه بندی رو انجام دادیم.
حالا اگر بخوایم بر اساس چند تا فیلد این دسته بندی رو انجام بدیم این کار رو باید بکنیم :
![[Pasted image 20250202164728.png]]
اینطوری هم میتونیم ازش استفاده کنیم که اول با where یه چیزی رو جدا کنیم و بعد بیایم و دسته بندی رو روی اونها انجام بدیم 
![[Pasted image 20250202165405.png]]
![[Pasted image 20250202165731.png]]
![[Pasted image 20250202191353.png]]
![[Pasted image 20250202191423.png]]
![[Pasted image 20250202191455.png]]

نکته ی خیلی مهمی که هست اینه که وقتی که میخوایم از توابع aggrigate یا همون سر جمعی استفاده کنیم باید اول group by رو روش انجام بدیم و بعد بیایم از اون توابع استفاده کنیم :
![[Pasted image 20250202192213.png]]
نکته ی بعدی :
![[Pasted image 20250202192723.png]]
![[Pasted image 20250202193909.png]]

![[Pasted image 20250202193728.png]]

![[Pasted image 20250202193743.png]]

![[Pasted image 20250202193806.png]]

خوب در قسمت پایین دو حالت رو نوشتیم یکی این وقتی که داریم به  دیتابیس کوئری میزنیم همونجا وقتی که میخوایم اطلاعات رو بگیریم به صورت sort شده بگیریم و حالت دوم اینه که دیتا رو همونطوری که در دیتابیس هست بگیریم و بعد بیاریم توی برنامه و بعد sort اش کنیم ،
برای این که برنامه بهینه باشه به لحاظ استفاده از ram از حالت اول استفاده میکنیم 

![[Pasted image 20250203075813.png]]

![[Pasted image 20250203080336.png]]

![[Pasted image 20250203080542.png]]

![[Pasted image 20250203080611.png]]
خوب حالا اگر ما یک مقدار max رو در یک ستون بخوایم باید بیایم order by decending روش انجام بدیم و بعد اولین دیتاش رو که میشه بیشترین مقدار رو بیاریم 


ولی میتونیم به جاش میتونیم از max by استفاده کنیم 
![[Pasted image 20250203095829.png]]

در تصویر پایین داره میگه که اگر بدون این که از to list یا to list async بخوایم استفاده کنیم بیایم کد رو بنویسیم ، برنامه میپوکه چون که در هر مرحله ای که داره foreach میزنه میره و دوباره دیتا رو میاره 
![[Pasted image 20250203100234.png]]

خوب میخوایم از skip and take استفاده کنیم چون نمیخوایم همه دیتا رو به صورت یکجا بیاریم و اینطوری میتونیم تکه تکه بیاریم و به کاربر نشون بدیم 

![[Pasted image 20250203101408.png]]

![[Pasted image 20250203101705.png]]
![[Pasted image 20250203101901.png]]
https://steven-giesel.com/blogPost/ce9ba892-bafe-4a62-8806-7ebf91f28a94

![[Pasted image 20250203124722.png]]

![[Pasted image 20250203124755.png]]

خوب توی کوئری دوم parameters p0 برابر شده با 3 


میخوایم به طور مثال یه ستون از یک جدول رو میخوایم 

خوب select , projection 

![[Pasted image 20250204094329.png]]

![[Pasted image 20250204094353.png]]

توی query میبینیم که توی قسمت select اومدیم و team id , created date , name رو select کردیم ولی موقع چاپ فقط از name استفاده کردیم حالا کاری که میخوایم انجام بدیم اینه که فقط اطلاعات یک ستون که میخوایم رو select کنیم و ازش استفاده کنیم

اینطوری team names تبدیل یه یه رشته string میشه ولی در حالت قبلی چون چند تا مورد دیگه هم داخلش بود یک object بودش
![[Pasted image 20250204094703.png]]

![[Pasted image 20250204095339.png]]

خوب حالا میخوایم از projection استفاده کنیم برای این که به طور مثال ببیشتر از یک فیلد رو بخونیم  
 با استفاده از اصول oop میتونیم یه annonymous data type رو درست  کنیم اینطوری :


![[Pasted image 20250204095745.png]]

![[Pasted image 20250204095802.png]]

اینطوری هم ازش استفاده میکنیم :
![[Pasted image 20250204095929.png]]

![[Pasted image 20250204100753.png]]

![[Pasted image 20250204100814.png]]

 o,خوب حالا میخوایم یه چیزی شبیه به dto یا data model یا view model رو ایجاد کنیم 
![[Pasted image 20250204102438.png]]

![[Pasted image 20250204102519.png]]

میرسیم به tracks ، خوب ef میاد object هایی که از query بدست میاد و داخل رم قرار میگیره رو میتونه track کنه و چک کنه ببینه چیزی تغییر کرده از زمانی که این دیتا وارد رم شده یا خیر تغییری نکرده  

خوب حالا این track کردن زمانی که بخوایم روی api ها کار کنیم به کار نمیاد چون که ما توی api ها میایم و یه کوئری رو اجرا میکنیم و بعد دیتاش رو میگیریم و  بعد هم برمیگرونیمش حالا در api ها نیازی به track کردن نیستش چون که اون end point که داریم باهاش دیتا رو تغغیر میدیوم با اون end point که داریم ازش دیتا رو میگیریم متفاوته 
![[Pasted image 20250204103615.png]]
![[Pasted image 20250204103727.png]]

جاهایی که قراره فقط دیتا رو بخونیم نیازی به track کردن نداریم 

نکته ای که هست اینه که tracking به صورت اتوماتیک انجام میشه و اگر بخوایم غیر فعالش کنیم باید بهش بگیم 

![[Pasted image 20250204104045.png]]
![[Pasted image 20250204104124.png]]

نکته ای که هست اینه که اینجا کوئری همون کوئری هستش ولی اینجا دیگه Ef نمیاد از resourse هایی که داره برای track کردن این دیتا استفاده کنه 

![[Pasted image 20250204104247.png]]

![[Pasted image 20250204113605.png]]

حالا اینجا یه مورد خیلی جالب داریم اونم استفاده از Iqueryable 

![[Pasted image 20250204224301.png]]

خوب توی مورد اول که مثل سری های قبلی نوشته ایم و از list استفاده کردیم توی این حالت تمام دیتا های teams رو میاریم 

دقت داشته باشید که در مورد بالا ما یک بار دیتا رو به صورت کلی اوردیم و از to list asyc استفاده کردیم یعنی یک بار دیتا به صورت کامل با کوئری از دیتابیس آورده شده و بعد اومدیم با استفاده از where دیتای مورد نظرمون رو جدا کردیم و بعد دوباره از to list استفاده کردیم 

ولی در مورد پایین میایم کوئری که میخوایم از دیتابیس بیایم دیتامون رو بیاریم به همون شکل کوئری رو مینویسیم و دیگه نیازی به این که کل دیتابیس رو بیاریم نیست 

![[Pasted image 20250205155709.png]]


![[Pasted image 20250205160332.png]]

![[Pasted image 20250205160347.png]]

![[Pasted image 20250205160452.png]]


نکته ی اول اینه که توی indexing دقت کنیم اگر index گذاری در دیتابیس باعث بهتر شدن سرعت query هامون میشه ولی  زیاد که باشه و در جای مناسب استفاده نشه دیتابیس رو کند میکنه در عملیات write کردن ولی در read کردن سرعت رو زیاد میکنه 

تا میتونیم از projection استفاده کنیم تا اون چیزی که فقط میخوایم رو از دیتابیس بگیریم 

از skip and take به خوبی استفاده کنیم برای این که اطلاعات زیاد از دیتابیس رو نیاریم

از async استفاده کنیم 

یه جاهایی ما مجبور هستیم که از sql query استفاده کنیم چون که ef نمیونه یه جاهایی Query های خیلی خوب درست کنه

از no tracking استفاده کنیم 

از batch operation استفاده کنیم ،  

![[Pasted image 20250205170604.png]]

  میرسیم به tracking 
   ![[Pasted image 20250205171223.png]]
خوب tracking زمانی خیلی خوب کار میکنه که برای کوئری خوندن دیتا و کوئری نوشتن یا همون تغییر دیتا دیتا از یه dbcontext استفاده کنیم 

 ![[Pasted image 20250205171345.png]]
خوب ef میاد به صورت اتوماتیک تغییرات که روی entity ها انجام میشه زمانی که از Save changes یا save changes async دنبال میکنه 

![[Pasted image 20250205171454.png]]
خوب چیزی که هست اینه که ما میتونیم از detect changes استفاده کنیم که در زمانی که save changes میخواد انجام و اینطوری میفهمیم که چه چیزهایی تغییر میکنه - بین کوئری و عملیات saving 

![[Pasted image 20250205171842.png]]

خوب tracking یه state داره و اونم هم مثال هاشو رو میگیم و این state بسته به این که عملیات یا همون operation که روی entity انجام میشه تغییر میکنه.

![[Pasted image 20250205172411.png]]
خوب حالا اینجا state ها رو توضیح داده و آخریش برای این استفاده میشه که وقتی ما فقط یه پراپرتی رو  تغییر دادیم و همون رو هم state اش رو تغییر میدیم و بقیه پراپرتی ها تحت تاثیر قرار نمیگیرن 

![[Pasted image 20250205172531.png]]

![[Pasted image 20250205172912.png]]

نکته ی خیلی مهم اینه که وقتی که از save changes داریم استفاده میکنیم تغییرات به صورت قسمتی اعمال نمیشن و transactional هستند به این معنی که اگر ما 3 تا entity رو تغییرات دادیم و 2 تا از اون ها تغییرات روشون اعمال شد ولی روی یکیشون fail شد کل اون پروسه fail میشه و تمامی تغییرات از بین میره 

خوب میخوایم دیتا رو بفرستیم بر اساس یه ترتیب خاص بچینیم  و داخل دیتابیس و دیتا رو بر اساس یه ترتیب خاص واردش کنیم دیتا رو 

![[Pasted image 20250205213417.png]]
![[Pasted image 20250205213554.png]]

![[Pasted image 20250205223333.png]]

اینجا اتفاقی که داره میوفته اینه که داره میگه که اینجا ما newCoach رو که اصلا دیتابیس اصلا چیزی نمیدونه راجع بهش رو میخوایم state اش رو تغییر بدیم به entity state added و از این به بعد هم track روش انجام میشه و وقتی که save changes رو call کنیم دیتاش وارد دیتابیس میشه 

اینجا توی متن دقت کنید اینطوریه که entity state از جنس enum هستش و added یه مقداره 

![[Pasted image 20250206105302.png]]

![[Pasted image 20250206105253.png]]
خوب اینجا مقداری که میخوایم توی دیتابیس وارد کنیم از فیلتر ef میگذره و اون میاد برای امنیت بیشتر اطلاعاتی که قراره وارد بشه رو paramiterized اش میکنه که اینجا p0 رو تاریخ و p1 رو اسم مربی که نوشتیم در نظر گرفته  
خوب اینجا در SQLITE میاد میگه که میتونیم ID که اون دیتا در دیتابیس قرار گرفته رو return کنیم 
ولی در sql server یه چیزی شبیه به scope identity که نمایشگر id هستش رو داریم 

![[Pasted image 20250206145428.png]]

خوب در کد بالا میخوایم دوتا مربی رو با اسم و تاریخ وارد دیتابیس کنیم برای این کار میایم این دو تا رو میریزیم توی لیست و بعد میایم با foreach وضعیت و state شون رو به حالت added تغییر میدیم و بعد میایم با save changes async همه ی اون ها رو وارد دیتابیس میکنیم ، حالا نکته ای که هست اینه که اگر بخوایم این رو در نظر داشته باشیم که یکی از این ها مشکل داشته و ارور داشته باشه هیچ کدوم از این دیتا ها وارد دیتا بیس نمیشن  حالا یه رویکرد دیگه هم که داریم اینه که save changes async رو ببریم داخل foreach اینطوری اون هایی که دیتاشون سالمه در دیتابیس ذخیره میشن و اونی که اورو داره ذخیره نمیشه ولی اینطوری با اون foreach هر بار داریم دونه دونه اطلاعات رو وارد میکنیم که خوب نیست ولی باز هم شاید نیاز بیزینس اینطوری باشه 
![[Pasted image 20250206145834.png]]
خوب حالا میتونیم با change tracker بیایم و تغییرات رو از زمانی که کوئری اجرا شده رو ببینیم یا قبل از این که بخوایم Save changes رو اجرا کنیم ببینیم چیا تغییر کردن 

![[Pasted image 20250206150135.png]]

![[Pasted image 20250206151145.png]]
خوب id که در نظر گرفته شده min int هستش و بعدش entity state هستش که شده added  و بعدش id رو به صورت temp در نظر گرفته  

خوب اینجا tracker میبینه که دو تا record جدید بهش اضافه شدن و منتظر هستن برای save شدن

![[Pasted image 20250206151638.png]]

![[Pasted image 20250206152342.png]]
خوب اینجا داره میگه که دیتا از زمانی که توی دیتابیس ذخیره شده تغییری روش انجام نشده و id اش هم توی دیتا بیس رو نوشته با تمامی مشخصاتش ، فقط نکته ای که هست اینه که زمانی که در دیتابیس ذخیره میشه از اونجا به بعد میتونیم به id اش دسترسی پیدا کنیم 


![[Pasted image 20250206151055.png]]


![[Pasted image 20250206152738.png]]
خوب نکته ی دیگه که هست اینه که ef میره  و مقادیر رو آپدیت میکنه منظورمون به طور مثال عوض شدن id از min int به 2 و 3 که اینجا اینجام شده

خوب حالا یه داستان دیگه ای هم که داریم اینه که ما درسته که میتونیم از foreach برای ذخیره سازی استفاده کنیم ولی بهتره که از add range async استفاده کنیم 

![[Pasted image 20250206153152.png]]


میرسیم به update :

![[Pasted image 20250206153550.png]]

خوب این رو باید دقت کنیم که وقتی که داریم از find استفاده میکنیم اون میره اول ram رو نگاه میکنه ، در صورتی که این آبجکتی که ما میخوایم track شده باشه ، حالا اگر track نشده باشه مستقیم میره و از دیتابیس میخونه 

به صورت دیفالت اگر ما توی کوئری یا توی db context هم تعیین نکرده باشیم به صورت دیفالت آبجکت ها track میشن  

![[Pasted image 20250206160210.png]]
![[Pasted image 20250206160406.png]]
![[Pasted image 20250206160856.png]]
نکته اینجا فقط اومده name رو که تغییر کرده رو آپدیت کرده 


![[Pasted image 20250206160637.png]]
خوب اگر بخوایم از Find استفاده کنیم find نیاز داره تا دیتا track شده باشه و داخل رم باشه تا بتونیم ازش استفاده کنیم در این شرایط که داریم از no tracking استفاده میکنیم باید بیایم و از first or default async استفاده کنیم 

![[Pasted image 20250206160824.png]]

![[Pasted image 20250206161509.png]]
![[Pasted image 20250206161524.png]]

خوب اینجا فقط اومده و id رو پیدا کرده و آورده و دیگه save changes اعمال نشده و دلیلش هم اینه که ef اصلا چیزی راجع به coach1 نمیدونه و برای این که Ef رو از اعمال تغییرات مطلع کنیم باید از update استفاده کنیم و state اون دیتامون رو در دیتابیس به حالت update بیاریم 

![[Pasted image 20250206162915.png]]

نکته ای که هست اینه که update range رو هم میتونیم استفاده کنیم اگر چند تا دیتا داشتیم 

![[Pasted image 20250206170415.png]]

![[Pasted image 20250206170457.png]]
خوب در مرحله ی اول چون دیتا داخل ram نیستش میره مستقیم از دیتابیس میارتش با این کوئری بالا 

![[Pasted image 20250206170535.png]]
در مرحله ی بعدی وقتی که update انجام میشه وضعیت id 2 به modified تغییر پیدا میکنه 
نکته ای که وجود داره اینه که با این که ما فقط name رو تغییر دادیم ولی چون توی حالت no tracking هستیم روی همشون modified اعمال میشه چون track نکرده از قبل که ببینه چی تغییر کرده 

![[Pasted image 20250206170613.png]]

در این مرحله آپدیت انجام میشه و state هم به صورت unchanged هستش 

خوب حالا یه روش دیگه هم برای آپدیت داریم که اون اینطوریه که بیام دستی state اون entity مون رو خودمون به modified تغییرش بدیم 
![[Pasted image 20250206173331.png]]

اینطوری ما به صورت دستی داریم به ef میگیم که برو این entity رو چک کن و track کن چون state اش رو تغییر دادیم 

میرسیم به delete:
![[Pasted image 20250207050818.png]]

![[Pasted image 20250207050829.png]]

حالت دوم :
![[Pasted image 20250207051036.png]]
![[Pasted image 20250207051045.png]]

نکته ما اگر بخوایم obejct رو delete کنیم حتما باید track شده باشه و آورده باشیمش توی رم و بعد پاکش کنیم یعنی در این حالت نمیتونیم از As no tracking برای آوردن دیتا استفاده کنیم 

این از ef 7 به اضافه شده که بتونیم بدون این که بخوایم دیتا رو بیاریم مستقیما دیتا رو حذف یا تغییرش بدیم :

![[Pasted image 20250207061136.png]]
![[Pasted image 20250207061214.png]]

![[Pasted image 20250207061258.png]]

حالا اگر چندین تا مورد داشتیم :
![[Pasted image 20250207061852.png]]


![[Pasted image 20250207062051.png]]

برای پاک کردن :

![[Pasted image 20250207061506.png]]

![[Pasted image 20250207111042.png]]

خوب این رو در نظر بگیرید که وقتی که از این دو متد استفاده میکنیم دیگه لازم نیست به صورت دستی بیایم add migration و بعد update data base رو به صورت کامند بزنیم چون این دو تا متد به صورت اتوماتیک انجامش میدن ولی این رو دقت داشته باشید که برای تست از اینها استفاده میشه نه برای production 

نکته ی خیلی خیلی مهم اینه که ما نمیتونیم وقتی که میخوایم در کلاس دیتایی که توی دیتابیس هستش بیایم و یه فیلد که not nullable باشه رو اضافه کنیم 

برای توضیح ساده تر 
![[Pasted image 20250207111813.png]]
اینجا ما از قبل name رو داشتیم حالا میخوایم team id رو اضافه کنیم خوب اینجا ما نمیتونیم فیلدی که nullable نباشه رو اضافه کنیم چون که دیتا هایی قبلی اونطوری به مشکل میخورن و اینجا ما باید nullable در نظر بگیریم که دیتاهای قبلی هم به مشکل نخورند 


![[Pasted image 20250209100248.png]]
اینطوری migration رو انجام میدیم 

![[Pasted image 20250209100506.png]]
![[Pasted image 20250209101810.png]]

![[Pasted image 20250209101333.png]]

![[Pasted image 20250209101345.png]]

خوب توی فولدر migration میبینیم که  migration به اسم AddedTeamIdtoCoaches اومده که حالا میخوایم اون update-database رو با کد روش انجام بدیم 
![[Pasted image 20250209102606.png]]
با این کامند میایم و میبنیم که اون migration روی دیتابیس اعمال شده یا خیر که میبینیم که توی applied زده true چون که یه بار من قبل از این که بخوام اسکرین بگیرم run اش کرده بودم 

![[Pasted image 20250209102814.png]]

![[Pasted image 20250209101933.png]]

![[Pasted image 20250209102938.png]]
![[Pasted image 20250209103532.png]]

خوب با استفاده از Ef bundles دیگه نیازی نداریم که پکیج هایی که مرتبط با cli هستش رو نصب کنیم یه قابلیت دیگه ای که بهمون میده اینه که توی pipeline ci/cd عملیاتش رو انجام میده و این که error handling بهتری داریم 

خوب در حالت عادی وقی که migration ها دارن اجرا میشن با اون دستور بالا هر کدوم از migraion ها یا انجام یا نمیشن یعنی اگر 3 تا migration داشتیم و دومی کار نکرد میره و سومی رو اجرا میکنه و ما بعدش باید بریم به صورت دستی ببینیم که کدومشون اجرا نشده و چرا 

ولی در این حالت کل migraion ها باید انجام بشن و اگر نشن پروسه fail میشه یعنی میشه everything or nothing اینطوری ما مطمئن هستیم که دیتابیسمون در استیت درستی قرار داره 

وقتی که داریم از ef bundle استفاده میکنیم معادل دستور update database داره عمل میکنه 

![[Pasted image 20250209104152.png]]
اگر داشتیم از linx استفاده میکردیم باید از اون قسمت داخل پرانتز هم استفاده کنیم 

اگر توی دستور powershell که efbundle.exe -- connection هستش آدرس رو بهش ندیم میره از آدرس که توی application setting تعیین کردیم برای دیتابیس استفاده میکنه 

خوب اگر ما یه migration جدید انجام دادیم بعد از این که file رو با efbundle اومدیم و generate کردیم ، در این حالت باید از force استفاده کنیم 

با این که این قابلیت ها رو داره ولی بهتره که از طریق کد بیایم این کار هارو انجام بدیم و دونه دونه مراحل رو برسی کنیم 

نکته ی جالب اینه که ما میتونیم توی package manager console بیایم از suggestion استفاده کنیم با زدن دکمه ی tab :
![[Pasted image 20250209124413.png]]

خوب یه نکته ای که هست اینه که اگر ما migration رو انجام داده باشیم و روی دیتابیس اعمال شده باشه نمیتونیم remove اش کنیم و برای این کار باید roll back کنیم

وقتی که میخوایم remove کنیم میاد و فایل و دیتابیس رو نگاه میکنه و اگر فقط فایل باشه و روی دیتابیس اعمال نشده باشه میشه پاکش کرد ولی اگر روی دیتابیس اعمال شده باشه نمیشه پاکش کرد و در این حالت باید بیایم و roll back کنیم

![[Pasted image 20250209124804.png]]

خوب حالا میخوایم roll back کنیم :
![[Pasted image 20250209135347.png]]
بعدش که get میگیریم میبینیم که Added team id to coach دیگه applied نیست :

![[Pasted image 20250209132426.png]]

![[Pasted image 20250209135408.png]]


خوب حالا وقتی که دوباره کامند update رو اجرا میکنیم برمیگرده به آخرین migration 

![[Pasted image 20250209183150.png]]
دوباره وقتی که get رو میزنیم 

![[Pasted image 20250209183227.png]]

![[Pasted image 20250209183253.png]]

![[Pasted image 20250209184400.png]]

![[Pasted image 20250209184811.png]]

خوب توی این حالت League id و Coach id رو FK در نظر بگیریم 
![[Pasted image 20250209190240.png]]

میتونیم از ICollection , Hashset , list استفاده کنیم که همه ی اینا T هستند 

![[Pasted image 20250209200707.png]]

![[Pasted image 20250209201245.png]]

وقتی که داریم از cascade استفاده میکنیم اینطوری میشه که وقتی که مثلا یه league رو پاک میکنیم تمام تیم هایی که داخلش بود هم پاک میشن 

![[Pasted image 20250209202451.png]]

![[Pasted image 20250209202652.png]]

-----
![[Pasted image 20250209204449.png]]

خوب برای کنترل تغییرات در دیتا بیس باید این رو بدونیم که  هر تغییری که ما توی entity مون یا توی db context مثلا اضافه کردن یه configuration یا کار های دیگه تمامی این تغییرات میاد با اون فایل snap shot مقایسه میشه و تغییرات به وجود اومده اگر مورد تایید ef  بود میاد فایل migration رو درست میکنه که حاوی action هایی هست که بیاد این تغییرات رو به وجود بیاره 

این تغییرات هم با دستور update انجام میشه  و یه قابلیت دیگه که داره اینه که میتونیم roll back هم کنیم 
این قابیلیت رو بهمون میده که تغییرات رو track کنیم در با استفاده از source control ها و این که در دیتابیس ها هم track میشه این تغییرات در ef migration history 

هر موقع که بخوایم یه دیتابیس جدید درست کنیم اون connection string رو عوض میکنیم و همه چی حل میشه 

![[Pasted image 20250209211144.png]]

معنی این ارور اینه که توی کلاس team یه فیلدی هست که not nullable هستش و ما داریم وقتی که seed میکنیم توی دیتابیس این فیلد رو هیچ مقداری براش نداشتیم و این که وقتی که not nullabe نیست حتما باید بهش مقدار بدیم ولی فعلا بهش ? رو میدیم تا ارور حل بشه  

![[Pasted image 20250209212125.png]]
خوب اینجا گفته که ممکنه یه سری از دیتا ها از بین برن و دلیلش اینه که ما اومدیم Team id رو به id تغییر دادیم 

![[Pasted image 20250209212204.png]]

![[Pasted image 20250209221414.png]]
 ![[Pasted image 20250209221641.png]]

خوب اون ارور قرمز قبلش این ارور زرد رنگ رو داره مینویسه ، برای حل این مشکل باید بیایم این کار رو کنیم 
باید بیایم توی چند مرحله این کار رو انجام بدیم و با یک migration نمیشه باید با چند تا migration انجامش بدیم 

![[Pasted image 20250209223934.png]]

![[Pasted image 20250209223941.png]]

خوب به خاطر این که دیتا توی دیتابی داریم که براساس همون پارامترهای قبلی ست شده این ارور رو میگیریم 

خوب تمامی اطلاعات توی دیتابیس رو پاک کردم  ومشکل حل شد 

![[Pasted image 20250209224437.png]]

خوب حالا اینطوری میشه که بعد از تمامی این داستان ها تازه باید بریم و فیلد Team id رو پاک کنیم و دوباره migration رو انجام بدیم و بعد آپدیت کنیم 

![[Pasted image 20250209224753.png]]
خوب حالا میخوایم از config استفاده کنیم :
![[Pasted image 20250210005241.png]]

![[Pasted image 20250210005302.png]]
خوب اینجا internal در نظر گرفتیم چون فقط داخل همین پروژه استفاده میشه و این که بعدش میایم IEntity type Configuration رو ارث بری میکنیم و بعد تعیین میکنیم که این تنظیمات رو برای کدوم کلاس میخوایم تنظیم کنیم که اینجا team هستش 

اون builder که در بالا داریم دقیقا مشابه با همین builder هستش 
![[Pasted image 20250210005436.png]]

![[Pasted image 20250210005653.png]]
 با اون builder کارهای زیادی میتونیم انجام بدیم :
 ![[Pasted image 20250210011643.png]]
![[Pasted image 20250210011747.png]]
![[Pasted image 20250210091132.png]]

خوب حالا اینجا داریم میگیم که همون اول که داری ساخته میشی این تنظیمات رو از team configuration بردارد و apply کن 

![[Pasted image 20250210092121.png]]
خوب حالا ممکنه که ما 50 تا دیگه کلاس داشته باشیم که بخوایم تنظیمات رو روش انجام بدیم  و به جای این که هر 50 تا رو بیایم اینجا بنویسیم از apply configuration from assembly استفاده میکنیم که این متد میاد و کل assembly رو میگرده و هرجایی که اینترفیس IEntity type configuration رو داشته باشه میره اون رو پیاده سازی میکنه  

![[Pasted image 20250210091822.png]]

  خوب حالا میخوایم بیینیم که Sql که برای این migration استفاده میکنیم چجوریه ؟
  برای فهمیدنش 
  ![[Pasted image 20250210104409.png]]
  ![[Pasted image 20250210104438.png]]
  خوب در سطر اول داره میگه که اگر EFmigrationHistory وجود نداشت بسازش 
  نکته ی بعدی اینه که از نوع transaction هستش 
  
![[Pasted image 20250210104815.png]]
در این تصویر بالا هم میگه که ef migration history رو آپدیت کن و بعد commit کن حالا migration بعدی با یک transaction جدید شروع میشه و همینطوری ادامه پیدا میکنه 

خوب موردی که هست اینه که اگر توی هرکدوم از این transaction ها دیتا وجود داشته باشه fail میشه و میره بعدی یعنی هر کدوم از transaction ها fail بشه میره بعدی رو اجرا میکنه 

خوب به همین دلیل ما میتونیم یه چیزی رو اضافه کنیم بهش به اسم idempotent که میاد اول چک میکنه و میبینه اگر دیتاش وجود نداشته باشه یا اون تغییر ایجاد نشده باشه میاد اون رو اجرا میکنه 

![[Pasted image 20250210110142.png]]

خوب البته این رو دقت داشته باشید که این قابلیت برای sqlite وجود نداره و به ارور میخوریم 

اینجا فرقش اینه که با اون if میاد چک میکنه - البته این رو از یه پروژه دیگه هستش

![[Pasted image 20250210110401.png]]


حتی میتونیم برای استفاده از idempotent بیایم range بدیم بهش اینطوری :
![[Pasted image 20250210110739.png]]

------
![[Pasted image 20250210111752.png]]

![[Pasted image 20250210112006.png]]

![[Pasted image 20250210142818.png]]

![[Pasted image 20250210142836.png]]

![[Pasted image 20250210142852.png]]

![[Pasted image 20250210143039.png]]

خوب اینجا برای ارتباط many to many باید چند تا ارتباط یک به چند داشته باشیم، که در اینجا میشه ارتباط HomeTeam در Match با یک team  و ارتباط AwayTeam در Match با یک تیم دیگه و از اون سمت ارتباط یک تیم با چندین match که Home یا Away هستن

![[Pasted image 20250210171337.png]]

وقتی که  داریم روابط رو تعیین میکنیم شبیه به parent child هستش حالا اینجا به طور مثال میایم و coach رو به عنوان parent قرار میدیم 

قابلیتی که داریم اینه که در هر دو طرف navigation رو داریم ولی  در یک طرف میتونیم FK رو قرار بدیم که دسترسی مستقیم به اون یکی داره 

یه حالت دیگه اینه که یک سمت navigation رو داریم و در یک سمت FK رو داریم که اینجا ef میاد از shadow propery ها استفاده میکنه 

یه حالت دیگه هم اینه که هر دوطرف هم navigation رو دارن و هم FK رو ولی در این حالت باید بریم و توی config خودمون این رو تنظیم کنیم 

حالا برای پیاده سازی بهتره که بیایم یه لیست خالی رو قرار بدیم توی proprty مون که به ارور نخوریم:

![[Pasted image 20250210173036.png]]


![[Pasted image 20250210173048.png]]
در اینجا درسته که TeamId  نداریم ولی خوده Ef با استفاده از shadow proprty یه FK رو برای دسترسی به اون تیمی که داخل کلاس Coach هستش رو بهمون داره میده و داره trace میکنه

نکته ی مهمی هست اینه که اگر به طور مثال ما دو تا MIGRATION داشتیم باشیم و بخوایم با هم این دو تا رو APPLIED کنیم اگر بین این دو تا تغییری باشه به ارور میخوریم به طور مثال توی اولی یه پراپرتی رو توی migration اولی اومدیم nullabe کردیم و توی migration دومی اومدیم not nullable کردیم و همین باعث ارور میشه برای همین بهتره که هر بار migration رو add میکنیم بعدش update رو انجام بدیم و بعد بریم سراغ migration بعدی 

حالا یه ارور دیگه که ممکنه بهش بربخوریم اینه که ما ساختار رو تغییر دادیم و بر اساس ساختار جدید دیتایی که همین الان توی دیتابیس هستش دچار مشکل میشه و با این ساختار نمیخونه و برای همین هم به ارور میخوریم و برای رفع ارور میایم همشون رو پاک میکنیم 