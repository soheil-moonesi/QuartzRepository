خوب توی این مطلب میخوایم راجع به type Casting صحبت کنیم، برای شروع با یه عکس شروع میکنیم:

![[{295DF43F-49F0-45B6-9EC1-05F6725D6003}.png]]

وقتی که میخوایم یه مقداری رو با یک تایپ به یه تایپ دیگه تبدیل کنیم میشه type casting

خوب implicit به طور اتوماتیک وقتی که یه دیتایی رو از یه تایپی ما سایز کوچکتر میفرستیم به تایپی که سایز بزرگتری داره، اتفاق میوفته

حالا **Explicit دقیقا برعکس مورده بالا هستش و ما باید به صورت دستی این تبدیل رو انجام بدیم.**

![[{55C7E76C-52EC-4F13-9EC3-BAED0E2FAC5A}.png]]

- **Implicit Casting** (automatically) — converting a smaller type to a larger type size  
    `char` -> `int` -> `long` -> `float` -> `double`
- **Explicit Casting** (manually) — converting a larger type to a smaller size type  
    `double` -> `float` -> `long` -> `int` -> `char`

حالا بیایم با مثال بریم جلو:

![[{6F3A4AB0-642E-4108-A7FB-6FF7439BA4BC}.png]]

توی کد بالا اومدیم مقدار i که تایپش int هست رو اومدیم داخل long قرار دادیم و هیچ اروری هم نداریم، چرا که تایپ long حافظه ی بیشتری داره و میتونه تایپ int رو که حافظه کمتری رو داره میتونه داخل خودش بدون از دست رفتن اطلاعات رو ذخیره کنه.

حالا اگر بخوایم برعکس این حرکت رو انجام بدیم، یعنی این که بیایم تایپ long رو بریزیم داخل int :

int k = j;

خوب وقتی که بخوایم این کار رو انجام بدیم با این ارور مواجه میشیم:

Error CS0266 Cannot implicitly convert type 'long' to 'int'. An explicit conversion exists (are you missing a cast?) TypeCasting

حالا راه حلی که داریم اینه که بیایم j رو تبدیل کنیم به int و بعد بیایم بریزیمش توی k :

int k =(int)j;

حالا اینجا اتفاقی که ممکنه بیوفته اینه اطلاعات از بین میرن یا تغییر میکننن، چون در انتقال از یک تایپ کوچکتر به تایپ بزرگتر، در صورت این که مقدار ای که داخل اون تایپ بزرگتر باشه و کامل فضای حافظه اختصاص داده شده رو گرفته باشه، اطلاعات به صورت ناقص به تایپ کوچکتر انتقال پیدا میکنه که باعث خطا در محاسباتمون میشه

ولی اگر مقداری که در تایپ بزرگتر هست به اندازه حافظه اختصاصی تایپ کوچکتر باشه، هیچ نقص اطلاعاتی پیش نمیاد.

مثال:

در همین مثال بالا وقتی که j رو میرزیم داخل k هیچ اطلاعاتی از بین نمیره ولی حالا فرض کنید که عدد j رو 99999999999999 در نظر بگیریم:

![[{9138EC67-89BA-4AAC-A745-CF170E966A9C}.png]]

اگر از k کنسول بگیریم میبینیم که در این حالت داره عدد 276447231 رو داره نشون میده، و علتش هم ناقص انتقال داده شدن اطلاعات هستش.

یه مثال دیگه:

![[{1FA65BA5-115B-4313-8359-5DA57A640360}.png]]

اینجا اتفاقی که میوفته اینه که مقداری که در b ذخیره میشه 5 هستش و دیتای اعشارش از بین میره .

حتی این قابلیت رو داریم که چند بار cast رو انجام بدیم:

![[{412BAF09-8501-455B-B9EE-B3B0A7AFB141}.png]]

الان اینجا اتفاقی که افتاده که اینه ما اول یه بار اومدیم به double رو به int تبدیل کنیم و بعد دوباره برای این که میخوایم توی یک متغییر double ذخیره اش کنیم، تبدیلش میکنیم به double ، حالا اینجا فقط مقدار صحیح و بدون اعشار a با تایپ double در b قرار میگیره

حالا بیایم یه مثال دیگه رو با هم ببینیم :

![[{B117DDB3-9C81-44B0-97B7-402AB0AB02DB}.png]]

حالا اینجا اتفاقی که میوفته اینه که اینجا تایپ خروجی که در جمع a و b داریم میشه double برای همین ارور داریم. که برای رفع ارور راه حلی که داریم اینه :

double c = a + b;

یا از این راه بریم:

int c = (int)a + b;

ولی طبیعتا در اینجا اعشار a رو برای محاسبه نداریم.

یه کار دیگه هم میتونیم بکنیم اینه که بیایم حاصل جمع a و b رو cast کنیم به این شکل:

int c = (int)(a + b);