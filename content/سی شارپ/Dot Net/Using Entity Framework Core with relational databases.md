![[Pasted image 20241207204640.png]]

خوب ADO بهمون یه سری قابلیت برای query زدن میده 
خوب Sql نوشتن خودش یه قابلیته
به این دلیل که مدیر دیتابیس میتونه این کوئری ها رو نگاه کنه و چک کنه و بهترشون کنه 
ولی قضیه اینه که sql نوشتن خیلی زمان بره و این که اون سرعتی هم که قراره خودش رو نشون بده اونقدری نیست که اصلا قابل توجه باشه 
به جای ado اومده ef رو بیشتر توضیح داده 

![[Pasted image 20241207204704.png]]

میگه که دانشی که توی sql یادمیگیریم دقیقا شبیه خیلی از دستورتی هستش که توی linq موجوده. 
ولی وقتی که میخوایم از ef استفاده کنیم نیازی نیست که inner , outter joint ها رو بدونیم چون خوده ef این ها رو هندل میکنه 
ولی این رو یادمون باشه که Ef خودش یه abstrraction هستش و معمولا اتفاقی که میفته اینه که این یه سری چیزها به صورت دیفالت توش قرار گرفتن 

![[Pasted image 20241207204735.png]]

خوب اینحا داره میگه که میان که یه convert رو از دیتابیس به آبجکت انجام بدن ولی بعضی از Data ها به این راحتی تبدیل به آبجکت نمیشن برای همین میایم از orm ها استفاده میکنیم که کار رو راحت و بهتر انجام بدیم

EF Core handle advanced concepts such as database functions, stored procedures, and mapping object hierarchies to tables

خوب ما اگر یه دیتابیس داشته باشیم میتونیم دیتا ها رو با هم مخلوط کنیم و بعد ازشون استفاده کنیم یا بریزیمشون توی یه جدول جدید 

همه مدلی هم میتونیم با استفاده از ef بیایم و migration ها رو انجام بدیم که کدمون تبدیل بشه به اون Sql 

![[Pasted image 20241207204814.png]]

خوب حالا یه داستانی که هست اینه که micro orm ها اون اوایل که اومده بودن خیلی کار راه بنداز و خوب بودن ، چون که برنامه نویس ها به کوئری ها تسلط بیشتری داشتن به کش و تبدیل داده ها هم همینطور ولی دیگه از .net 6 به بعد اختلافشون با ef همینطوری کمتر و کمتر میشد 

![[Pasted image 20241207204847.png]]

حالا میخوایم یه برنامه درست کنیم که کتاب هایی که خوندیم رو طبقه بندی میکنه 
حالا میخوایم اطلاعات کتاب ها رو هر چی که بهش مربوط هستش رو ذخیره کنیم یا بتونیم اضافه کنیم یا حذف کنیم یا آپدیت کنیم خوب باید یه جوری طراحی کنیم که اگر سرور پوکید دیتا ها رو بشه استفاده کرد و این که قابل scale باشه و پایدار 

![[Pasted image 20241207204905.png]]

خوب قبل از این که بخوایم بفهمیم که ef چطوری کار میکنه میتونیم بیایم یه console app بنویسیم 

![[Pasted image 20241207204932.png]]

خوب با استفاده از in memory میتونیم بدون این که به یه دیتابیس جدا وصل کنیم ef رو میتونیم کارمون رو راه بندازیم ولی از این مدل دیتابیس نباید در تست استفاده کنیم 

![[Pasted image 20241207205007.png]]

خوب اول بیایم یه کلاس کتاب درست کنیم 

![[Pasted image 20241207205017.png]]

![[Pasted image 20241207205026.png]]

خوب ef میاد و یه جدول بر اساس entity مون درست میکنه 
هر جدول دیتابیس معمولا یه کلید داره برای شناسایی هر سطر 
اگر اون entity یه پرارپتی به اسم id داشته باشه خوده ef میاد اون رو به عنوان PK در نظر میگیریه طبق convention 
حالا اگر بخوایم مثلا isbn بشه PK میایم از attribute استفاده میکنیم key 

![[Pasted image 20241207205052.png]]

خوب book میشه یه جدول 

![[Pasted image 20241207205106.png]]


میگه که ef فقط اون entity هایی که به db context ربط دران رو میشناسه و باهاشون کار داره 
ما متیونیم چندین تا dbcontext داشته باشیم که همشون دارن به یه دیتابیس اشاره میکنن ولی باید حواسمون باشه که تسک هایی به صورت موازی و چند تایی از یه dbcontext استفاده نکنند چون thread safe نیست 
page 89 org

![[Pasted image 20241207205123.png]]

خوب برای این که بیایم کلاس book  رو به dbContext اضافه کنیم باید بیایم یه کلاس جدید بسازیم که از dbcontext ارث بری میکنه 

میایم catalogContext و اینطوری میایم به کد اضافه اش میکنیم 

![[Pasted image 20241207205621.png]]

اگر از ورژن های 6 یا قدیمی تر استفاده میکردیم احتمالا به یه اروری میخوردیم که books بهش assign value بهش نشده 
خوده ef ورژنش معمولا جداست ولی بهتره که ورژن Ef با .net همخونی داشته باشه ولی این قانون سفت و سختی نیست 
از ef 7 به بعد دیگه این قضیه که برای null value ها بخواد ارور بده کنسل شد برای این که میاد مقادیر رو میاد  assign میکنه بر اساس dbset based properties 

اگر هم اروری بود میشه که از این روش برطرفش کرد فقط کافیه که بهش یه مقدار بدیم 

![[Pasted image 20241207205636.png]]

اینجا ما این warning رو داریم 

![[Pasted image 20241207205658.png]]

خوب وقتی که که این warning میاد ما چند تا کار میتونیم بکنیم :

![[Pasted image 20241207205713.png]]

اینجا به خاطر پراپرتی title که در کلاس book هستش داره ارور میده و میتونیم برای برطرف کردنش بیایم یا براش ? بزاریم که nullable بشه یا بیایم یه constructor درست کنیم و بگیم که هر وقت که میخواد این کلاس درست بشه باید یه اسم هم بگیریم همون موقع و بهش بدیم 


![[Pasted image 20241207205803.png]]

خوب dbset نمایانگره لیست entity ها هستش .
خوب entity های ef نمایانگر های abstract هستند و به جدول فقط خلاصه و محدود نمیشن 
میتونن object های دیگه رو represent کنن مثله database views و همچنین entity ها اسمشون رو به ef core میدن 
توی این کتاب هر entity دو تا نقش داره هم کلاسه و هم جدول 

نکته : onconfiguring متد داره مموری داخل حافظه رو مشخص میکنه و این ، این معنی رو نمیده که dbcontext فقط برای یه مدل یا یه تایپی از دیتابیس ها درست شده - یعنی اینطوری نیست و برای همه مدل دیتابیسی طراحی شده 

خوب ما میتونیم خودمون هم option رو به صورت جدا خودمون تعریف کنیم ، اگر بخوایم dbcontext option builder خودمون رو درست کنیم => میتونیم option هم درست کنیم منظورشه
یه متدی هست که توی بخش 8 میگه برای این که سوییچ کنیم از دیتابیس in memory  یا تستی یه دیتا بیس اصلی 

خوب برای این که بخوایم Catalog context رو تست کنیم باید بیایم یه سری کار ها رو توی program انجام بدیم :

![[Pasted image 20241207210629.png]]

خوب با استفاده از save changes تمام تغییرات که ایجاد شده رو روی context اعمال میکنیم که اینجا این context مون میشه همون دیتابیسی که روی memory هستش 
خوب book یه پراپرتی به اسم id داره که با استفاده از convention ها ما اون در نظر گرفتیم که کلید اصلی هستش 
خوب ef core برای هر entity نیاز داره که یه شاخص داشته باشه یه شاخص خاص برای هر جدول در دیتابیس 
اکثر دیتابیس های یه قسمتی دارند مخصوص شاخص ها یا ستون شاخص ها که معمولا auto increment مقدارش میره بالا برای هر دیتای جدیدی که واردش میشه 
خوب اینجا اولیه که وارد میشه id اش 1 هستش دومی 2 و ... 

![[Pasted image 20241207210742.png]]

وب query ها از linq استفاده میکنن مثلا از order by برای مرتب کردن کتاب ها با استفاده از id شون . حالا اگر بخوایم نزولی مرتبشون کنیم میایم از order by desending استفاده میکنیم 

خوب اگر ما Save changes رو بیاریم بعد از query یا همون foreach که زدیم چیزی رو نشون نمیده ، و دلیلش این هست که تا زمانی که این آبجکت هایی که از book ساختیم رو وارد دیتابیس نکنیم که اون چیزی توش نیست که بخواد نمایش بده 
خوب dbset بهمون دسترسی برای داخل دیتا بیس رو میتونه بده نه اون چیزی توی کد تغییر کرده یا اضافه شده 

![[Pasted image 20241207210941.png]]

page 91
کلاس books در database context از نوع enumerable collection هستش.
خوب enumerable در این context به معنی چیزی که اینترفیس IEnumarable رو پیاده سازی کرده و میتونه یه itirator داشته باشه که توی آیتم های اون collection دونه به دونه دور بزنه یا بخونتشون 
یه مدل خاصی از Enumerable ها هستن که بهشون میگیم Queryable ، و اینکه IQerayable مشخصن برای  LINQ طراحی شده و یه جورایی میشه extent شده IEnumerable 
و linq Extention ها کاربرد های زیادی دارن و به چند تا کاتولوگ تقسیم بندی میشن 
محدود کننده :خوب where هستش که فیلتر میکنه یا محدود میکنه ورودی های enumarable رو به خروجی enumabrable 
نمایش دهنده : select میاد خروجی رو بر اساس ورودی درست میکنه 
پارتیشن بندی: take و skip میاد یه قسمت یا یه slice از ورودی enumerable رو به یه خروجی کوچکتری که enumrable هستش تبدیل میکنه 
به ترتیب کردن : orderby و orderbyDescending میان رورودی ها enumberable رو به خروجی های Enumerable تبدیل میکنن 
دسته بندی کردن با استفاده از group by انجام میشه چند دسته از enumrable ها رو به یه bucket تبدیل میکنه 
همسان سازی و متمایز سازی : union , distinct عملیاتی که روی چند سری از دیتا ها انجام میشه و میاد یکسان سازی یا متمایز سازی یا بهم چسبوندن روش انجام میده 
تبدیل کردن : to list , to array , to dictionary اینها enumerable رو میان materilized میکنن به این معنی که تمام و کل enity رو میان برمیگردونن و لود میکنن و میارن 
المنت ها : first , first or defualt , last این ها المنت ها رو بر اساس position شون برمیگردونن 
صحت سنجی : any , all از این ها برای این که ببین المنت ها شرایط و condition های لازم رو دارن استفاغده میشه و خروجی true و false ازش استفاده میشه 
مجموع سازی sum , count , min از این ها برای انجام محاسبات عددی استفاده میشه 

این لیستی که بالا نوشته شده دیگه همه چیو نگفته فقط در حد اینکه یه ایده کلی بگیریم نوشته شده.
یه قابلیت دیگه ای هم که داره اینه که میتونیم این ها رو با هم ترکیب کنیم و ازشون استفاده کنیم 
به طور مثال first or default رو میتونیم روش محدودیت بزاریم و اینطوری دیگه نمیخواد از where استفاده کنیم 
یه داکیومنت معروفم هست که لینکش اینه 

![[Pasted image 20241207211159.png]]


میگه که از interpolated string هها اینجا استفاده شده با استفاده از $ و اینطوری میتونیم مقادیر رو وارد string کنیم 

![[Pasted image 20241207211214.png]]

خوب اینجا دیدیم که یه  new زدیم و یه آبجکت book رو درست کردیم 
خوب ابجکت ها با استفاده از constructor درست میشن ولی book اینجا constructor نداره ولی C# اتوماتیک این رو فرض میکنه که constructor داره ولی هیچ argument ای نداره 
حالا توی c# های قدیمی تر اینطوری باید مینوشتیم :

![[Pasted image 20241207211317.png]]![[Pasted image 20241207211347.png]]


خوب یه راه برای کوتاه کردن این کد اینه که بیایم برای book یه constructor درست کنیم که یه پارامتر به اسم title  داره 
خوب این کار وقتی که پرارپرتی های زیادی داریم حماقته چون اونجوری باید بیایم برای همشون یه چیزی رو ست کنیم 
خوب C# یه راه رو میده برای خلاصه سازی که بیایم اون مقادیری که public هستند رو همون اول که دارن ساخته میشن بهشون مقدارش رو بدیم و مقادیر رو بریزیم توی comma seperated list و مقداردهیشون رو انجام بدیم 
new book()
new book {}
new book() {}
![[Pasted image 20241207211430.png]]

خوب وقتی که این پروژه رو اجرا میکنیم به چند تا هشدار میخوریم که یکیش اینه که اون پارامتری که داریم میتونه null باشه 
خوب این هشدار برای یه عملکرد nullable در پروژه هستش که میتونیم اینطوری بر طرفش کنیم :
Nullable disable Nullable
توی متن نشون داده 
ولی بهتره که این کار رو نکنیم چون این قانون و عملکرد باعث میشه که بهتر کد بزنیم 



![[Pasted image 20241207211708.png]]

خوب اولین تغییری که باید به book بدیم اینه که پرارپرتی id هستش که از نوع int هستش و نمیتونه null باشه مگر اینکه خودمون براش تعیین کنیم که null هم میتونه باشه و بعدیش میرسیم به tittle که string هستش .
خوب c# string ها از نوع immutable refrence type ها هستند و میتونن null هم باشن 