
خوب وقتی که میزنیم روی propetties دیتابیس 
![[{7E7F262E-2159-4DA6-896F-EC52F4544B5F}.png]]

این اطلاعات رو بهمون نشون میده 

![[{4995D258-7914-45DB-A498-3A5C87D05DFC}.png]]

حالا وقتل که میخوایم یه دیتابیس جدید بسازیم ، اینجا collation رو زده default ولی ما ممکنه ندونیم که default این دیتابیس چیه برای همین قبل از این که بخوایم کاری کنیم توی دیتاببس اولش بریم از توی همخون صفحه اول properties  ببینیم که collation اش چیه ، چون که این default ای که اینجا هست میاد از اون ارث بری میکنه 

اگر بخوایم چیزی غیر از اون دیفالته باشه میزنیم روش و تغییرش میدیم به طور مثال اگر خواستیم که این دیتابیس جدید اطلاغات هندی ذخیره کنیم 

اگر موقع ساخت collation رو اشتباه انتخاب کنیم بعدش دیگه خیلی سخت میشه درستش کرد 

![[{430F2FC3-F029-481E-8C01-1DDBDE3A11B6}.png]]



![[{F8CC8963-1ED6-4C6E-9561-FA49B4BACD29}.png]]
https://sqlconjuror.com/tag/recovery-models/

![[{A7293F15-7B15-4E7E-9743-3DC606CD8AAE}.png]]

https://www.sqlmvp.org/explore-recovery-models-in-sql-server-with-examples/

 توی حالت full میاد از اول هر اتفاقی که توی دیتا بیس افتاده رو در خودش ذخیره میکنه و اگر فایل  ldf حجمش تموم بشه با مکانیزم auto grow میاد حجمش رو زیاد میکنه 

اگر simple باشه هیچوقت log file بزرگ نمیشه همیشه به همون اندازه که همون اول بهش اختصاص دادیم باقی میمونه، هر وقت که تموم بشه فضا میاد از اول روش re write میکنه اطلاعات بعدی رو 

در سیستم های خیلی بزرگ به علت این که حتی زمان برای ریکاوری نداریم و فرصتش رو نداریم از full استفاده نمیشه به جاش از یه مکگانیزیمی به نام mirroring استفاده میشه 

نکته : ما در زمان ساخت دیتابیس وقتی میایم COALLATION رو تعیین میکنیم به این معنیه که همیشه زبون اول انگلیسی هستش و ما در حقیقت با انتاخاب COALLTAION زبان دوم رو داریم انتخاب میکنیم برای ذخیره سازی در دیتابیس 

![[{E23FC301-D628-48DE-B50C-19C498AF64BD}.png]]

ما میتونیم دیتابیس هایی که ورژن های پایین تر دارن رو ازشون بک آپ بگیریم و ببریم در ورژهای بالاتر ولی برعکسش امکان پذیر نیست 

وقتی که بک آپ ورژن هایی پایین تر رو اوردیم داخل ورژن های بالاتر اینجا میایم و compability اش رو تتغییر میدیم به همون ورژن بالاتر و اینطوری خودش میاید تبدیل دیتابیس قدیمی رو به جدید انجام میده 

بعضی از مواقع که مثلا برنامه نوشته شده که با ورژن های قدیمی تر compatible هستش دیگه نمیاریم روی ورژن های جدید تر و فقط انتقالش دادیم به engine جدید ولی دیگه ورژنش رو تغییر نمیدیم 

برای پاک کردن دیتابیس از این روش استفاده میکنیم :
![[{6CB97552-7A8C-4A3E-9D78-6669F809B3A6}.png]]

دیتابیس رو با فایل ها mdf و ldf و همه چی رو پاک میکنه 

اون تیک connection رو هم بزنیم اول میاد connection رو قطع میکنه و بعد پاکش میکنه 

![[{5480856D-90AC-4A99-8443-819F47F2DAB9}.png]]

معادل کاری که در قسمت بالا انجام میدیم 

اگر بخوایم هم به صورت تستی بیایم Drop رو انجام بدیم بهتره که اول یه محیط transaction درست کنیم و بعد بیایم drop رو انجام بدیم که بعدش اگر خواستیم بتونیم roll back اش کنیم 


![[{9C9BE3F6-23C3-40E5-A63A-81BED45DE04F}.png]]
![[{73C01717-5804-441C-87FD-CFF865D68A93}.png]]

در این دو قسمت بالا میان برای یوزهایی که به دیتابیس ها دسترسی دارن سطوح مجاز دسترسی براشون تعیین میشه 

![[{95796ECF-AD80-48E6-9F9C-19705D9BE3A9}.png]]

بعد از این قسمت نوع permission های مجاز هم براشون تعیین میشه 

جدول ها یک سری اطلاعات مرتبط با هم رو در یک جدول کنار هم قرار میدن و این که خوده جدوال هم میتونن با هم ارتباط داشته باشند 

اینطوری میایم یه جدول درست میکنیم در دیتابیسمون 
![[{A87D4832-4413-4061-8C9E-71DB06C26B00}.png]]

نام گذاری در جدول ها فارسی نباشه و از space به هیچ عنوان  استفاده نشه به جاش از __ استفاده کنیم 

 
![[{FD92979C-CCA9-428C-8EE1-052971BF8848}.png]]

اون علامت سوال به این معنیه که خودمون اونجا تعیین میکنیم که چقدر رو نگه دارن که این مقدار از 1 بایت تا 8000 بایت متغییر هستش و میتونیم از این بین اون مقداری که لازم داریم رو تعیین کنیم 

در دسته بندی اولیه به طور مثال نام و نام خانوادگی و عکس همه در کنار هم در دیتابیش ذخیره میشه ولی در دسته بندی دوم دیگه عکس در کنار اطلاعات دیگه نیستش و عکس به صورت جداگانه در یک قسمت دیگه هارد ذخیره سازی میشه و آدرسش میاد در کنار این اطلاعات قرار میگیره و به همین دلیل در نوع دوم سرعت دسترسی پایین تر هستش 

اگر فایلمون از 2 گیگابایت بیشتر باشه میشه file stream  کلا دیگه توی دیتا بیس ذخیره نمیکنه 

و به همین دلیل وفتی که از دیتابیس میایم بک آپ میگیریم دیگه عکس ها با اون فایل های بک آپ گیری در یک جا نیستند و باید بریم از جای دیگه بیاریمشون 

و این که image هم depricate شده به دلیل پیچیدگی که در ذخیره سازی این مدل از دیتاها در سخت افزار داره 

![[{3914E8EF-77CA-4AEC-B2F3-72A9CF02CF4C}.png]]

اینجا این دیتاتایپ ها از Ascii استفاده میکنن و این یعنی این که از زبان انگلیسی و زبان colattion این دیتا تایپ ها ساپورت میشن 

![[{5A8342CF-D47C-4FA9-BAAD-6A7A4C32EE8B}.png]]

حالا فرق fixed با variable چیه توی اولی که fixed هستش میاد هر چقدر از مثلا 10 که تعیین کردیم فضا مونده باشه اون رو میاد با white space پرش میکنه ولی دومی نه اینطوری نیست 

سرعت دسترسی در بالایی بیشتر هستش چون هر تیکه از داده معلومه که در چه قسمتی قرار داره بعنی این که اولین داده از 0 تا 9 و بعدی از 10 تا 19 و دیتاهای بعدی ولی در نوع دوم چون ممکنه که متغییر باشه باید بره و دیتا رو پیدا کنه و بعد برگردونه 

![[{0B799B20-602B-4FBE-BFB3-FF5509C7D2ED}.png]]

 خوب یه روش استفاده از این دیتاتایپ ها اینه که بیایم به طور مثال شماره ملی رو توش سیو کنیم چون شماره ملی رو در دیتا تیاپ های عددی نمیتونیم سیو کنیم چون صفر قبل از عدد در اون مدل معنی نداره و حذف میشه 

جایی که مطمئن هستیم که عدد همیشه پر میشه مثل شماره کارت ملی یا تلفن

![[{64F9368D-0712-46A5-A788-C26688AD5CB9}.png]]


توی  uni code هر زبانی رو میتونیم ذخیره کنیم ولی حجم بیشتری رو اشغال میکنه و بک آپ گیری طبیعتا حجم بیشتری رو میخواد و انتقال دیتا روی شبکه هم حجم بیشتری رو میبره 

![[{B146C183-50A4-4F60-AA8E-97DDECEC0D85}.png]]


![[{2D934F20-4929-4052-9FCE-923290E3150A}.png]]

![[{2807DE56-3D06-4726-A81C-484FCA557730}.png]]

برای محاسبات خوب نیستن چون میاد اعداد رو روند میکنه 

![[{A4A7CFBD-9686-4976-A247-48A48901316F}.png]]

![[{AC7BFD97-0539-4A3E-B40D-9A0977C12F02}.png]]
از بالا به پایین سرعت دسترسی کمتر میشه 

اگر اعداد نسبتا کوچک هستن از currency استفاده بشه خوبه 


خوب sql server تاریخ شمسی رو ساپورت نمیکنه ولی oracle ساپورت میکنه 

![[{1495E08D-5764-45D2-98B8-921C517DF411}.png]]

![[{85AD981F-D484-4801-977C-D9A055051702}.png]]

![[{00F36FCB-4E46-428C-AC95-D9EC63F33BA5}.png]]
خوب null با صفر و فیلیدی که هیچی توش نیست و یا یه space توشه متفاوت هستش ، null یعنی هنوز هیچ اطلاعاتی به این فیلد اختصاص داده نشده و یا مقدار دهی نشده 

![[{6512F16E-1082-42E5-9B0B-6710A777BF18}.png]]

خوب uniqueidentifer برای زمانی استفاده میشه که بخوایم مقادیر تصادفی ایجاد کنیم ، نیوتن با الگوریتم new id برای تولید این اعداد تصادفی استفاده میشه 

![[{1B7C620B-52CC-4D06-83E8-CDCA1BA72937}.png]]

بعد میخوایم این اطلاعات رو پر کنیم 

![[{65A8E834-3754-4EA5-8D6F-948EA043095E}.png]]

![[{2997203C-6952-4A3A-B6B8-58F89986CF43}.png]]

قسمت x خودش به صورت اتوماتیک پر میشه 
![[{B73025E2-BC9B-4EBE-87A9-1B70BBC7B868}.png]]

![[{659C36B9-8061-4F67-BBF0-D2AA86A15F0C}.png]]

خوب اینجا میتونیم حتی برای هر کدوم از فیلد های توی جدول بیایم به صورت جداگانه coallation تعیین کنیم 

خوب یه قسمتی توی proprties هستش که میگه به صورت دیفالت برای مقدار اون فیلد چی بزارم 
![[{1BD616DC-E0AC-481A-BA6B-A7477DD38B31}.png]]

اینجا یعنی اگر هیچ مقداری براش تعیین شنده بیاد و ali توش بنویسه 


خوب اینجا به طور مثال برای پر کردن x میایم و از الگوریتم new id استفاده میکنیم 
![[{776B716B-BBCA-4D04-A85F-EDE792785FB5}.png]]

![[{0BABA5D6-00D0-40F8-84B1-250358B79FEB}.png]]

![[{5EDEC362-A05D-42E2-BC64-D92947A3B0AA}.png]]

خوب timestamp وقتی که ما یه دیتابیس رو میسازیم ساخته میشه و مقدارش صفر یا صفر هگزادسیمال هستش 

هر جا هم ازش استفاده بشه به صورت incrimental عددش یه دونه یه دونه میره بالا 

![[{38DEA443-DDF6-4216-9BEC-DA8F5534ACB7}.png]]

![[{B11DBE62-80A9-4CB9-AC4C-F123E892CB8F}.png]]


حالا یه جدول دیگه توی همین دیتابیس درست میکنیم بعد فیلدی که توش بهش مقدار میدیم میاد آخرین time stamp که توی این دیتابیس هستش رو پیدا میکنه و بهش 1 اضافه میکنه و مینویستش

![[{1160FFC9-4348-49C3-BB99-7F1661A4EA06}.png]]

![[{686A50E4-9761-4B6D-AFB4-FC81197247AE}.png]]

نکته اینه که time stamp در سطح دیتابیس کنترل میشه و استفاده میشه 

حالا میریم توی table قبلی و آپدیت و تغییر روش انجام میدیم و کد 2 رو به 3 تغییر میدیم   

![[{B0D737F4-D860-4278-9DA8-8EBEDF1BD2DA}.png]]

حالا دوباره TIMESTAMP اش رو نگاه کنیم میبنیم که تغییر کرده 

![[{76D70DC8-54BE-4A72-A817-8143039A84E9}.png]]

موتونیم ازش به عنوان change detector  استفاده کنیم 

2:11

سناریو فرض کنید که میخوایم حقوق یک شخص رو بالا ببریم ، حالا این بالا بردن حقوق در یک لحظه توسط دو نفر میخواد انجام بشه یعنی این که به طور مثال مدیر مالی و حسابدار میان و هر دو اطلاعات حقوقی شخص رو میگیرن بعد به طور مثال حسابدار میاد حقوق رو 2 برابر افزایش میده و مدیر مالی هم میاد 3 برابر افزایش میده اینجا اتفاقی که میوفته  اینه که خطای همزمانی اتفاق میوفته که برای رفع کردنش یه سری راه حل داریم 

راه حلش اینه که برای هر فیلد بیایم timestamp در نظر بگیریم و همیشه همراه با اون دیتای فیلد اون timestamp رو باهاش بگیریم 

اینطوری مثلا یه حسابدار میاد اطلاعات حقوقی رو میگیره با timesmap و حقوق رو افزایش میده ، حالا وقتی که مدیر مالی میخواد افزایش حقوق رو انجام بده نمیتونه ، چرا؟ چون مدیر مالی اومده دیتا رو با time stamp قبل از تغییر حسابدار گرفته و وقتی که میخواد اطلاعات جدید رو ثبت کنه به دلیل این که time stamp جدید با timestamp قدیم برابر نیست نمیتونه آپدیت رو انجام  بده و مجبوره اول اطلاعات جدید رو با timestamp جدید بگیره و بعد آپدیت رو انجام بده

معمولا این روش با استفاده از time و تاریخ به صورت معمول انجام میشه و از timestamp استفاده نمیشه 

در دیتابیس ها همیشه یه تاریخ ثبت در نظر میگیرند و تاریخ آخرین تغییرات 

![[{8FDF00B4-374A-4D9E-8992-CDBC17ED5B92}.png]]

خوب Sql varient میتونه هر دیتایی از هر تایپی داخلش ذخیره بشه و این اصلا خوب نیست

![[{76F432FE-03EA-4F1D-8C82-E8B7F51EA9DC}.png]]

حالا میخوایم این اطلاعات رو به صورت xml خرچی بگیریم 
![[{027F01C9-86E8-401C-BC3F-36FFFA667E56}.png]]

این شکلی میشه :
![[{650ED264-D66D-4742-8A73-521CF9814838}.png]]

نکته ای در خصوص xml ها هستش اینه که دیتاهایی که nuil هستش رو اصلا نمیاره :
![[{FB4007C1-8A6A-4B27-8E5C-04BF85FEE941}.png]]
به طور مثال رکورد 7 قیمتش null هستش 
![[{5040A727-63D7-48AE-A63D-61DD157EE460}.png]]
این ها برای زمانی استفاده میشه که برنامه نویس ها میخوان دیتا ها رو نمایش بدن یا باید xml بگیرن یا json برای نمایش و انتفال دیتا 

![[{F3C70CE5-AB5E-4289-82EB-6A1CC07A1CF3}.png]]

![[{3FC214C5-DD10-42C8-989E-544DA2267E62}.png]]

اولی میشه طول و عرض جغرافیایی

![[{C57C4364-D8BC-4459-ADBA-AC26B5814A63}.png]]

دومی یه zone جغرافیای رو ذخیره میکنه :
![[{15A350A3-720E-4F83-9808-BF8EB961AC1C}.png]]

خوب حالا برای بدست آوردن تایم و تاریخ میایم اینطوری عمل میکنیم :
![[{DB7DBBCB-DC66-487D-BE92-41D3F7883D9E}.png]]

از تابع getdate استفاده میکنیم به صورت اتومات این کار در زمان پر شدن یا تغییر دیتا ها انجام بشه 
![[{B045A573-4299-4968-8AE2-7F016FEA1439}.png]]


خوب حالا میرسیم به فیچر identity  که نکته ای که هست اینه که ما فقط میتونیم یک فیلد رو در هر جدول براش این فیچر رو در نظر بگیریم و اون column باید حتما از جنس int باشه و باید غیر null  باشه و اینجا defualt binding هم دیگه معنایی نداره 

![[{98A30353-A247-42C5-8EF9-2A98FFD2E9DF}.png]]

برای فعال کردنش هم کافیه که identitty specification رو yes بزنیم ، خوب identity seed یعنی از چه عددی شروع بشه و  identity incriment هم یعنی گامش چند تا چند تا باشه برای افزایش 

![[{94DE5F07-B684-4BC3-828C-58BAA441BEEF}.png]]

خوب معمولا میایم natinal id و natinal id int رو در نظر میگیریم تو حالتی که int هستش باید بیایم و عدد رو بشمریم و هر تعدادی که کم بود صفر رو بزاریم پشتش ولی این یه Cost زمانی داره ولی از اون سمت موقع سرچ کردن ، سرچ روی اعداد بهتره تا character 

روش میکسش اینطوری میشه که موقع سرچ کردن از int استفاده میکنیم و موقع های دیگه از character 

![[{55F5F326-FD21-4167-ABD4-315B21C87C8C}.png]]

بدون اعشار و ممیز و چیزای دیگه توش نمینویسیم 

![[{2F95D3C6-C3E6-4995-8EE7-D70DF39CF109}.png]]

خوب حالا یه نکته ای که هست وقتی که داریم جدول ها رو در دیتابیسمون میسازیم یه پیشوند میگیره 

![[{58419452-57EE-4BC0-B54E-019DD422DF1D}.png]]

به طور مثال اینجا پیشوندش dbo هستش که بهش میگن schima که بعدا در مورد access ها و permission ها استفاده میشه 

DBO = Data base owner 

اگر بخوایم select انجام بدیم روی جدول ها schima ای که میخوایم فراخوانی کنیم اسمش چیزی به غیر از dbo باشه اون اسم رو هم باید بنویسیم ولی برای اون هایی که dbo دارند لازم نیست 

خوب حالا میخوایم یه جدول رو با استفاده از کد درستش کنیم : 

![[{16474484-61F7-4A47-975A-CB0B2D92A7A0}.png]]


برای درست کردن جدول میزنیم create table بعد اسم جدول رو میزنیم , بعدش توی پرانتز میایم اسم فیلد رو میزنیم و بعد نوع و تایپ اون داده رو تعیین میکنیم و بعد میایم اگر خصوصیتی داره یا میخوایم براش خصوصیتی تعیین کنیم یا تابعی یا فانکشنی که میخوایم استفاده کنیم رو مینویسیم و بعد , میایم فیلد بعدی رو مینویسیم و تا آخر همینطوری 

به طور مثال اومدیم identity رو نوشتیم و توی پرانتز عددی که ازش شروع بشه رو نوشتیم و بعد نوشیتم که چند گام چند گام باید افزایش پیدا کنه، برای first name امکان null بودن رو گذاشتیم , و برای entry date هم اومدیم گفتیم که default دیتایی که قراره توش قرار بگیره بیاد از تابع get date استفاده کنه 

خوب برای قسمت اول ما اومدیم و code رو نوشتیم و بعد int 

خوب حالا میایم و یه جدول میسازیم :
![[{A531945E-BE7B-4790-BF02-056C31EFAA57}.png]]

و میگیم که a , b  رو داریم و c میشه a+b +1 خوب این اینطوری در جدول به ما نمایش داده میشه ، همونطوری که میبینید دیتا تایپی براش نذاشتیم 

![[{B972D253-8F7E-44AD-BA56-9E00AD147DF0}.png]]

هیچ دیتا تایپی نداره و نکته ای که

![[{92F63DC9-1CF4-4D0E-9C1E-3C9610373450}.png]]

حالا is persist اگر no باشه این column هیچ فضایی رو در هارد هیچوقت اشغال نمیکنه 
 هیچ فضایی در هارد رو نمیگیره و هر زمان که بخوان فراخونیش کنیم میاد با استفاده از a و b میاد میسازتش و بهمون میده 

اگر yes باشه هم میره توی هارد ذخیره اش میکنه 

اگر فرمول خیلی پیچیده نیست no بزنیم اگر فرمولش سنگینه و پیچیده است yes باشه 

حالا فرض کنید که میخوایم first name و last name رو به هم بچسبونیم 

![[{865DBA85-BD7C-4A19-A2F6-58920B6ADDA8}.png]]

معمولا اینطوری ، از اینجا تغییرات رو اعمال نمیکنیم 

![[{68361331-AD7B-4291-81B0-65A99BEF7064}.png]]

![[{821DEFB4-DE07-4A44-9DDF-7F4819A80F49}.png]]

تمام دستورات رو اینجا نوشته 
![[{86650231-8931-41BC-AD9A-F1B96F82E385}.png]]

![[{C9C4886E-22B6-40EC-B154-0A83B7EA8157}.png]]

![[{2C34540B-C976-4A01-8EE7-F4803C3B4DAB}.png]]

[[SQL Server]]
