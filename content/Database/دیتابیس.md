
خوب وقتی که میزنیم روی propetties دیتابیس 
![[{7E7F262E-2159-4DA6-896F-EC52F4544B5F}.png]]

این اطلاعات رو بهمون نشون میده 

![[{4995D258-7914-45DB-A498-3A5C87D05DFC}.png]]

حالا وقتل که میخوایم یه دیتابیس جدید بسازیم ، اینجا collation رو زده default ولی ما ممکنه ندونیم که default این دیتابیس چیه برای همین قبل از این که بخوایم کاری کنیم توی دیتاببس اولش بریم از توی همخون صفحه اول properties  ببینیم که collation اش چیه ، چون که این default ای که اینجا هست میاد از اون ارث بری میکنه 

اگر بخوایم چیزی غیر از اون دیفالته باشه میزنیم روش و تغییرش میدیم به طور مثال اگر خواستیم که این دیتابیس جدید اطلاغات هندی ذخیره کنیم 

اگر موقع ساخت collation رو اشتباه انتخاب کنیم بعدش دیگه خیلی سخت میشه درستش کرد 

![[{430F2FC3-F029-481E-8C01-1DDBDE3A11B6}.png]]



![[{F8CC8963-1ED6-4C6E-9561-FA49B4BACD29}.png]]
https://sqlconjuror.com/tag/recovery-models/

![[{A7293F15-7B15-4E7E-9743-3DC606CD8AAE}.png]]

https://www.sqlmvp.org/explore-recovery-models-in-sql-server-with-examples/

 توی حالت full میاد از اول هر اتفاقی که توی دیتا بیس افتاده رو در خودش ذخیره میکنه و اگر فایل  ldf حجمش تموم بشه با مکانیزم auto grow میاد حجمش رو زیاد میکنه 

اگر simple باشه هیچوقت log file بزرگ نمیشه همیشه به همون اندازه که همون اول بهش اختصاص دادیم باقی میمونه، هر وقت که تموم بشه فضا میاد از اول روش re write میکنه اطلاعات بعدی رو 

در سیستم های خیلی بزرگ به علت این که حتی زمان برای ریکاوری نداریم و فرصتش رو نداریم از full استفاده نمیشه به جاش از یه مکگانیزیمی به نام mirroring استفاده میشه 

نکته : ما در زمان ساخت دیتابیس وقتی میایم COALLATION رو تعیین میکنیم به این معنیه که همیشه زبون اول انگلیسی هستش و ما در حقیقت با انتاخاب COALLTAION زبان دوم رو داریم انتخاب میکنیم برای ذخیره سازی در دیتابیس 

![[{E23FC301-D628-48DE-B50C-19C498AF64BD}.png]]

ما میتونیم دیتابیس هایی که ورژن های پایین تر دارن رو ازشون بک آپ بگیریم و ببریم در ورژهای بالاتر ولی برعکسش امکان پذیر نیست 

وقتی که بک آپ ورژن هایی پایین تر رو اوردیم داخل ورژن های بالاتر اینجا میایم و compability اش رو تتغییر میدیم به همون ورژن بالاتر و اینطوری خودش میاید تبدیل دیتابیس قدیمی رو به جدید انجام میده 

بعضی از مواقع که مثلا برنامه نوشته شده که با ورژن های قدیمی تر compatible هستش دیگه نمیاریم روی ورژن های جدید تر و فقط انتقالش دادیم به engine جدید ولی دیگه ورژنش رو تغییر نمیدیم 

برای پاک کردن دیتابیس از این روش استفاده میکنیم :
![[{6CB97552-7A8C-4A3E-9D78-6669F809B3A6}.png]]

دیتابیس رو با فایل ها mdf و ldf و همه چی رو پاک میکنه 

اون تیک connection رو هم بزنیم اول میاد connection رو قطع میکنه و بعد پاکش میکنه 

![[{5480856D-90AC-4A99-8443-819F47F2DAB9}.png]]

معادل کاری که در قسمت بالا انجام میدیم 

اگر بخوایم هم به صورت تستی بیایم Drop رو انجام بدیم بهتره که اول یه محیط transaction درست کنیم و بعد بیایم drop رو انجام بدیم که بعدش اگر خواستیم بتونیم roll back اش کنیم 


![[{9C9BE3F6-23C3-40E5-A63A-81BED45DE04F}.png]]
![[{73C01717-5804-441C-87FD-CFF865D68A93}.png]]

در این دو قسمت بالا میان برای یوزهایی که به دیتابیس ها دسترسی دارن سطوح مجاز دسترسی براشون تعیین میشه 

![[{95796ECF-AD80-48E6-9F9C-19705D9BE3A9}.png]]

بعد از این قسمت نوع permission های مجاز هم براشون تعیین میشه 

جدول ها یک سری اطلاعات مرتبط با هم رو در یک جدول کنار هم قرار میدن و این که خوده جدوال هم میتونن با هم ارتباط داشته باشند 

اینطوری میایم یه جدول درست میکنیم در دیتابیسمون 
![[{A87D4832-4413-4061-8C9E-71DB06C26B00}.png]]

نام گذاری در جدول ها فارسی نباشه و از space به هیچ عنوان  استفاده نشه به جاش از __ استفاده کنیم 

 
![[{FD92979C-CCA9-428C-8EE1-052971BF8848}.png]]

اون علامت سوال به این معنیه که خودمون اونجا تعیین میکنیم که چقدر رو نگه دارن که این مقدار از 1 بایت تا 8000 بایت متغییر هستش و میتونیم از این بین اون مقداری که لازم داریم رو تعیین کنیم 

در دسته بندی اولیه به طور مثال نام و نام خانوادگی و عکس همه در کنار هم در دیتابیش ذخیره میشه ولی در دسته بندی دوم دیگه عکس در کنار اطلاعات دیگه نیستش و عکس به صورت جداگانه در یک قسمت دیگه هارد ذخیره سازی میشه و آدرسش میاد در کنار این اطلاعات قرار میگیره و به همین دلیل در نوع دوم سرعت دسترسی پایین تر هستش 

اگر فایلمون از 2 گیگابایت بیشتر باشه میشه file stream  کلا دیگه توی دیتا بیس ذخیره نمیکنه 

و به همین دلیل وفتی که از دیتابیس میایم بک آپ میگیریم دیگه عکس ها با اون فایل های بک آپ گیری در یک جا نیستند و باید بریم از جای دیگه بیاریمشون 

و این که image هم depricate شده به دلیل پیچیدگی که در ذخیره سازی این مدل از دیتاها در سخت افزار داره 

![[{3914E8EF-77CA-4AEC-B2F3-72A9CF02CF4C}.png]]

اینجا این دیتاتایپ ها از Ascii استفاده میکنن و این یعنی این که از زبان انگلیسی و زبان colattion این دیتا تایپ ها ساپورت میشن 

![[{5A8342CF-D47C-4FA9-BAAD-6A7A4C32EE8B}.png]]

حالا فرق fixed با variable چیه توی اولی که fixed هستش میاد هر چقدر از مثلا 10 که تعیین کردیم فضا مونده باشه اون رو میاد با white space پرش میکنه ولی دومی نه اینطوری نیست 

سرعت دسترسی در بالایی بیشتر هستش چون هر تیکه از داده معلومه که در چه قسمتی قرار داره بعنی این که اولین داده از 0 تا 9 و بعدی از 10 تا 19 و دیتاهای بعدی ولی در نوع دوم چون ممکنه که متغییر باشه باید بره و دیتا رو پیدا کنه و بعد برگردونه 

![[{0B799B20-602B-4FBE-BFB3-FF5509C7D2ED}.png]]

 خوب یه روش استفاده از این دیتاتایپ ها اینه که بیایم به طور مثال شماره ملی رو توش سیو کنیم چون شماره ملی رو در دیتا تیاپ های عددی نمیتونیم سیو کنیم چون صفر قبل از عدد در اون مدل معنی نداره و حذف میشه 

جایی که مطمئن هستیم که عدد همیشه پر میشه مثل شماره کارت ملی یا تلفن

![[{64F9368D-0712-46A5-A788-C26688AD5CB9}.png]]


توی  uni code هر زبانی رو میتونیم ذخیره کنیم ولی حجم بیشتری رو اشغال میکنه و بک آپ گیری طبیعتا حجم بیشتری رو میخواد و انتقال دیتا روی شبکه هم حجم بیشتری رو میبره 

![[{B146C183-50A4-4F60-AA8E-97DDECEC0D85}.png]]


![[{2D934F20-4929-4052-9FCE-923290E3150A}.png]]

![[{2807DE56-3D06-4726-A81C-484FCA557730}.png]]

برای محاسبات خوب نیستن چون میاد اعداد رو روند میکنه 

![[{A4A7CFBD-9686-4976-A247-48A48901316F}.png]]

![[{AC7BFD97-0539-4A3E-B40D-9A0977C12F02}.png]]
از بالا به پایین سرعت دسترسی کمتر میشه 

اگر اعداد نسبتا کوچک هستن از currency استفاده بشه خوبه 


خوب sql server تاریخ شمسی رو ساپورت نمیکنه ولی oracle ساپورت میکنه 

![[{1495E08D-5764-45D2-98B8-921C517DF411}.png]]

![[{85AD981F-D484-4801-977C-D9A055051702}.png]]

![[{00F36FCB-4E46-428C-AC95-D9EC63F33BA5}.png]]
خوب null با صفر و فیلیدی که هیچی توش نیست و یا یه space توشه متفاوت هستش ، null یعنی هنوز هیچ اطلاعاتی به این فیلد اختصاص داده نشده و یا مقدار دهی نشده 

![[{6512F16E-1082-42E5-9B0B-6710A777BF18}.png]]

خوب uniqueidentifer برای زمانی استفاده میشه که بخوایم مقادیر تصادفی ایجاد کنیم ، نیوتن با الگوریتم new id برای تولید این اعداد تصادفی استفاده میشه 

![[{1B7C620B-52CC-4D06-83E8-CDCA1BA72937}.png]]

بعد میخوایم این اطلاعات رو پر کنیم 

![[{65A8E834-3754-4EA5-8D6F-948EA043095E}.png]]

![[{2997203C-6952-4A3A-B6B8-58F89986CF43}.png]]

قسمت x خودش به صورت اتوماتیک پر میشه 
![[{B73025E2-BC9B-4EBE-87A9-1B70BBC7B868}.png]]

![[{659C36B9-8061-4F67-BBF0-D2AA86A15F0C}.png]]

خوب اینجا میتونیم حتی برای هر کدوم از فیلد های توی جدول بیایم به صورت جداگانه coallation تعیین کنیم 

خوب یه قسمتی توی proprties هستش که میگه به صورت دیفالت برای مقدار اون فیلد چی بزارم 
![[{1BD616DC-E0AC-481A-BA6B-A7477DD38B31}.png]]

اینجا یعنی اگر هیچ مقداری براش تعیین شنده بیاد و ali توش بنویسه 


خوب اینجا به طور مثال برای پر کردن x میایم و از الگوریتم new id استفاده میکنیم 
![[{776B716B-BBCA-4D04-A85F-EDE792785FB5}.png]]

![[{0BABA5D6-00D0-40F8-84B1-250358B79FEB}.png]]

![[{5EDEC362-A05D-42E2-BC64-D92947A3B0AA}.png]]

خوب timestamp وقتی که ما یه دیتابیس رو میسازیم ساخته میشه و مقدارش صفر یا صفر هگزادسیمال هستش 

هر جا هم ازش استفاده بشه به صورت incrimental عددش یه دونه یه دونه میره بالا 

![[{38DEA443-DDF6-4216-9BEC-DA8F5534ACB7}.png]]

![[{B11DBE62-80A9-4CB9-AC4C-F123E892CB8F}.png]]


حالا یه جدول دیگه توی همین دیتابیس درست میکنیم بعد فیلدی که توش بهش مقدار میدیم میاد آخرین time stamp که توی این دیتابیس هستش رو پیدا میکنه و بهش 1 اضافه میکنه و مینویستش

![[{1160FFC9-4348-49C3-BB99-7F1661A4EA06}.png]]

![[{686A50E4-9761-4B6D-AFB4-FC81197247AE}.png]]

نکته اینه که time stamp در سطح دیتابیس کنترل میشه و استفاده میشه 

حالا میریم توی table قبلی و آپدیت و تغییر روش انجام میدیم و کد 2 رو به 3 تغییر میدیم   

![[{B0D737F4-D860-4278-9DA8-8EBEDF1BD2DA}.png]]

حالا دوباره TIMESTAMP اش رو نگاه کنیم میبنیم که تغییر کرده 

![[{76D70DC8-54BE-4A72-A817-8143039A84E9}.png]]

موتونیم ازش به عنوان change detector  استفاده کنیم 