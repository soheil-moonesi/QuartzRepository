برای select کردن میتونیم اسم جدول و بعد اسم اون فیلدی که میخوایم رو بنویسیم 

![[{0848EE17-C45D-4DBF-B0B8-98EE680048C7}.png]]

حالا میرسیم به قسمت aggrigate function ها  

![[{21EA74DA-4BC9-4A51-8625-C42B861F409C}.png]]

میره تعداد دیتا ها رو میخونه 

َ![[{9AA9F416-8D8B-462D-A4EE-8AE486391EB7}.png]]

نکته : اینجا هر دو تا دستور یک کار رو دارن انجام میدن ولی وقتی که از * استفاده کردیم میره تمام اون جدول رو میاره توی رم و بعد شروع میکنه به شمارشش و سرعتش پایینه ولی پایینه سرعتش بیشتره 

حالا وقتی که روی یه فیلد دیگه میزنیم 

![[{7D974DE7-2E37-497B-9F62-82794416F39D}.png]]
اینجا نتیجه میشه 16 در صورتی که میبایست 18 تا باشه دلیلش اینه که دو تا از کتاب ها  price شون null  هستش برای همین هم 16 تا نشون میده 

نکته اینه که null در توابع aggrigate تاثیر داده نمیشد 

بهترین حالت اینه که count رو روی PK بزاریم 

خوب نکته ی بعدی اینه که اینجا اسم جدول no column name هستش 

تایم 41 

خوب حالا همونطوری که میبینید اینجا نتیجه ای که ما میده no column name داره یعنی اسمی نداره برای همین ما برای این که بخوایم در آینده ازش استفاده کنیم میایم و بهش اسم میدیم :

![[{97F6650E-3793-4B99-A0E7-5CB33FC69A48}.png]]

![[{53ABE75A-A3EB-4634-A297-E145981017A3}.png]]

نکته max و min رو میتونیم روی کارکتر ها پیاده سازی کنیم ، این ها بر اساس حرف الفبا این کار رو انجام میده 

کوئری بنویسید که تعداد نویسندگانی که حداقل یک کتاب دارند رو بهمون بده 

![[Pasted image 20250121164311.png]]


![[{071DE0B6-5E60-487D-94EF-5C88B879735C}.png]]

خوب توی تصویر بالا میایم جدول titles رو با tittleauthor با کلید ta.title_id و t.title_id با هم inner join میکنیم و بعد میایم authors رو با tittle author که یه جدول میانی هستش join میزنیم


![[{E3336D42-1D28-4009-AFE8-ADD40BE982BB}.png]]

خوب اینجا وقتی که از روش بالا میریم میشه 25 تا نام نویسنده در صورتی که 23 تا داریم و علتش این هست که در روش اول یک کتاب دوباره اومده یعنی نویسنده 1 و 2 و بار دیگر نویسنده 2 و 1 رو اورده 

تایم: 59

خوب حالا اگر بخوایم نویسنده هایی رو بخوایم که حداقل یک کتاب چاپ کرده اند 

اینطوری میتونیم بدستش بیاریم :

![[{71C03757-3961-493C-8C13-B8AF98A88CA1}.png]]

حالا همنوطوری که میدونیم این هم اشتباه به همون دلیل بالا پس برای همین باید از یه قابلیت دیگه استفاده کنیم تا دیتای درست رو بدست بیاریم اون هم استفاده از distinct هستش چون تمام رکورد های تکراری رو میاد حذف میکنه یعنی کتاب هایی که به طور مثال دو تا نویسنده دارند دو بار نوشته شده اند 

![[Pasted image 20250121163810.png]]


![[{33DC47B1-8F9A-45E7-8701-9E070061E302}.png]]

خوب یه راه دیگه هم اینه که این کار رو انجام بدیم ولی بهینه و درست نیست 

![[Pasted image 20250121163401.png]]

![[Pasted image 20250121163435.png]]

توضیحات distinct : 

![[{7ABE0C68-8893-4A68-B42E-8C9D18D697DA}.png]]

![[Pasted image 20250121161439.png]]

![[{9788E804-5ECF-4094-AF76-AFA5EC26C643}.png]]

![[{34CDA9F3-F825-497E-B23D-73C68541AB29}.png]]

https://www.programiz.com/sql/select-distinct

![[Pasted image 20250121165050.png]]

در حالتی که 3 تا هستش میشه خوده جدول اصلی چون هیچ کدوم از اون دیتاها به صورت 3 تایی تکراری نیستند .

![[Pasted image 20250121165809.png]]

![[Pasted image 20250121165827.png]]

![[Pasted image 20250121165840.png]]

![[Pasted image 20250121165912.png]]

https://www.programiz.com/sql/group-by

![[Pasted image 20250121170241.png]]

![[Pasted image 20250121170416.png]]

کوئری که کد کتاب و تعداد فروش هر کتاب رو لیست کنه 

![[Pasted image 20250121171235.png]]

![[Pasted image 20250121184959.png]]

![[Pasted image 20250121184949.png]]

الان نام کتاب و تعداد فروش کتاب رو میخوایم ، الان نیاز داریم که با group by بیایم و join هم بزنیم :

میتونیم قرارداد بزاریم که نام هر فیلدی که اومد بعد از from همون رو بزاریم 

![[Pasted image 20250121230501.png]]

![[Pasted image 20250121230606.png]]


![[Pasted image 20250121230811.png]]

نکته ای که در مورد تصویر بالا وجود داره اینه که وقتی که ما اومدیم گفتیم که بعد از این که join انجام بشد بیا و qty ها رو اومدیم و جمعشون زدیم با هم ، حالا وقتی که اینها رو با هم جمع میزنیم یعنی باید یه group by رو هم روشون انجام بدیم اگر انجام ندیم نمیشه و به ارور میخوریم 

ما وقتی که از توابع سر جمعی استفاده میکنیم فقط یه مقدار به ما خروجی میده پس بنابراین اون سمت جدول هم باید یه جوری یکسان سازی کنیم با سمت راستش که ما از توابع سرجمعی استفاده کردیم و در اینجا باید از group by استفاده کنیم 

یه نکته  ای که اینجا هست اینه که ما کلا 18 تا کتاب دارم ولی اینجا 16 تاشو داره نمایش میده و دلیلش هم اینه که اون دو تا کتاب فروشی نداشته اند ، ولی با این حال باز هم میخوایم بیارمشون توی این لیست حالا برای این کار میایم و left join روش انجام میدیم :

![[Pasted image 20250122082241.png]]

نام کتاب و مبلغ فروش کتاب رو لیست کنه 

اول تمامی فیلد هایی که میخوایم رو میاریم و بعد روشون میایم عملیات رو انجام میدیم 

![[Pasted image 20250122084324.png]]

نکته : left join سرعتش بیشتر از inner join هستش چون فقط یک طرف رو چک میکنه ولی inner هر دو طرف رو چک میکنه 

نام ناشر و مبلغ فروش هر ناشر 

![[Pasted image 20250122110111.png]]

![[Pasted image 20250122112738.png]]

![[Pasted image 20250122112804.png]]

![[Pasted image 20250122112851.png]]

حالا اگر بخوایم تمامی ناشر ها توی این قسمت لیست بشن باید بیایم و left join بزنیم 

![[Pasted image 20250122113340.png]]

اینجا گفتیم که تمامی ناشر ها باشند حتی اگر تا الان کتابی منتشر نکرده باشند 
![[Pasted image 20250122113153.png]]

توی حالت بعدی گفتیم که ممکنه کتاب چاپ کرده باشن ولی فروش نداشته اند پس برای همین هم left join میزنیم 

اگر میومدیم از title شروع میکردیم نوشتن کوئریمون رو اونجا باید از right join استفاده میکردیم 

حالا اگر بخوایم null بنویسه 0 میایم از is null استفاده میکنیم :

![[Pasted image 20250122115501.png]]

![[Pasted image 20250122115510.png]]

ما یه oprator داریم که is null هستش و این برای چک کردن null بودن یا نبودن استفاده میشه، 
نکته ای که هست اینه که IsNull اینجا فانکشن هستش و فانکشن ها صورتی رنگ میشه متنشون 

کوئری که نام خانوادگی نویسنده و تعداد کتاب هایی که نوشته رو لیست کنه 

![[Pasted image 20250122123754.png]]

![[Pasted image 20250122123928.png]]
نکته : اینجا اتفاقی که افتاده اینه که ما دو نفر متفاوت رو داریم ولی فامیلیشون یکسان هست و با این مدل کد نتیجه ای که به ما میده اشتباه حتی اگر اسم رو هم اضافه کنیم ممکنه باز هم اشتباه پیش باید چرا که ممکنه دو نفر متفاوت باشن ولی اسم و فامیلیشون یکسان باشه 
بهترین راه اینه که از id استفاده کنیم 
بهترین راه اینه که دسته بندی براساس فیلد primery key انجام بشه 
حالا اگر دسته بندی رو روی فیلی به جر pk هم انجام دادیم بیایم و pk رو کنارش بزاریم 
اینجا اومدیم کنار au lname اومدیم و au_id رو اضافه کردیم 
نکته ای که اینجا هست اینه که ما au id که PK هستش رو توی group by اوردیم ولی توی select نیوردیم که این کار مجازه ولی برعکسش مجاز نیست 

و توی دسته بندی میتونیم بر اساس هر چیزی که میخوایم اون رو انجام بدیم و لزومی نداره که همه اون ها رو توی Select بیاریم 

هر فیلیدی رو که خارج از aggergate function توی select بنویسیم باید بر اساسش بیایم دسته بندی رو انجام بدیم 

![[Pasted image 20250122124626.png]]

خوب میتونستیم که کوئری رو به صورت ساده تری بنویسیم »
![[Pasted image 20250122125413.png]]

و بعد اینطوری مینویسیم »
![[Pasted image 20250122125844.png]]

ما اومدیم و اون select اولی رو توی پرانتز گذاشتیم و اسمش رو k گذاشتیم که میشه یه جدول مجازی که خودمون درست کردیم و بعد هم اومدیم توی select اولی از tc که داخل جدول k هستش استفاده کردیم 

توی کوئری های که میزنیم هر چقدر که تعداد رکورد های اطلاعاتی کمتری باشه کوئری بهتر عمل میکنه و سریع تره 

اون جدول k که درست کردیم بهش میگن جدول مشتق شده یا همون drived table 

![[Pasted image 20250122131433.png]]

![[Pasted image 20250122131517.png]]

هر چقدر عدد  پایینتر باشه سرعتش بیشتره 

نکته اینه که به طور مثال هر جا که داریم join میزنیم اطلاعات کمتری شامل باشه ، سرعت کوئری بیشتره 

نکته ی دیگه اینه که اینجا به صورت تخمینی و براساس sytax که نوشته شده داره این اطلاعات رو به ما میده 

![[Pasted image 20250122132510.png]]

خوب اینجا با استفاده از دیتای واقعی میاد و عملیات رو انجام میده ونتیجه مقایسه رو نشون میده :
![[Pasted image 20250122132846.png]]

![[Pasted image 20250122132913.png]]

اگر کوئری پیچیده و دیتا سنگین بود از این مورد استفاده نکنیم و از مورد تخمینی با SYNTAX استفاده کنیم چون که اگر بخواد به صورت همزمان دو تا کوئری سنگین رو اجرا کنه میپوکه

کوئری نام و نام خانواگی نویسنده و سهم نویسنده از مبلغ فروش کتاب ها رو لیست کنه 

![[Pasted image 20250122163758.png]]

![[Pasted image 20250122164259.png]]

![[Pasted image 20250122164410.png]]

خوب اینجا میبینیم که این دو تا عددی که بدست آومده با هم تفاوت دارند و دلیلش هم اینه که ما برای کتاب هایی که دو تا نویسنده دارن تعداد فروش رو 2 برابر حساب کردیم یعنی اگر یک کتاب با دو نویسنده 1 بار فروخته شده ما چون اون به ازای هر نویسنده 

![[Pasted image 20250122172058.png]]

![[Pasted image 20250122172107.png]]


![[Pasted image 20250122214901.png]]

![[Pasted image 20250122215045.png]]
این همون قضیه ای که بالاتر گفتیم 

خوب حالا برای درصد این که هر نویسنده چقدر سهم داره باید به royal paper مراجعه کنیم »

![[Pasted image 20250122215207.png]]

اینجا به طور مثال نویسنده ی اول bu111 40 درصد سهم از فروش و دومی 60 درصد از سهم فروش 

![[Pasted image 20250122215554.png]]

اینجا اومدیم برای چک کردن این کوئری رو نوشتیم

![[Pasted image 20250122215620.png]]

اینجا درست میشه : 

![[Pasted image 20250122215745.png]]
اینجا عددی که بدست آوردیم با اون چکی که اون بالا انجام دادیم یکی شد که این یعنی درسته 


برای عملیات wizard 
![[Pasted image 20250122221230.png]]

![[Pasted image 20250122221246.png]]

کل دیتا بیس یا چیزهای دیگه 

وقتی که روی دومی میزنیم میتونیم جدول ها رو تعیین کنیم

![[Pasted image 20250122221335.png]]

![[Pasted image 20250122223650.png]]

![[Pasted image 20250122223752.png]]

![[Pasted image 20250122224058.png]]